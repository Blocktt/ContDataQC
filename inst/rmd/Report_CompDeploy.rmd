---
title: "Report, Deployment Comparison"
subtitle: "ContDataQC"
author: "`r Sys.getenv('USERNAME')`"
date: "`r format(Sys.time(), '%Y-%m-%d %H:%M:%S')`"
output:
  html_document:
    toc: yes
    toc_depth: 3
    toc_float: no
  word_document:
    toc: yes
---
```{r setup, include=FALSE}
knitr::opts_chunk$set(results='asis', echo=FALSE, warning=FALSE)
# needed for trouble shooting
boo_DEBUG <- FALSE
if(boo_DEBUG==TRUE){
  myConfig <- file.path(system.file(package="ContDataQC"), "extdata"
                        , "config.ORIG.R")
  source(myConfig)
  
  
  
  
  
  
}
```

# DATA FILE INFORMATION





```{r data_file_info}
  # Report Info
  myReportDate <- format(Sys.Date(), ContData.env$myFormat.Date)
  cat(paste("**Report Date:** ", myReportDate, "\n\n", sep=""))
  myUser <- Sys.getenv("USERNAME")
  cat(paste("**Generated By:** ", myUser, "\n\n", sep=""))
  
  #filename
  cat("**Filename:** ", strFile, "\n\n",sep="")

  mySiteID <- data.import[1,ContData.env$myName.SiteID]
  
  cat(paste("**SiteID:** ",mySiteID,"\n\n",sep=""))
  
  if(exists("fun.myData.DateRange.Start")==TRUE){
    POR.Requested <- paste(fun.myData.DateRange.Start
                           ," to "
                           ,fun.myData.DateRange.End
                           , sep="")
  } else {
    POR.Requested <- "NA"
  }
  cat(paste("**Period of Record, Requested:** "
            ,POR.Requested,sep=""
            ,collapse="\n\n"))
  
  myNumRecords <- nrow(data.import) 
  # 20170228, mod from records 10 and 11 to half way point
  
  # myTimeDiff <- difftime(data.import[10,ContData.env$myName.DateTime]
  #,data.import[11,ContData.env$myName.DateTime],units="mins")
  #x <- data.import[,ContData.env$myName.DateTime]
  myT <- strptime(data.import[,ContData.env$myName.DateTime]
                  ,format=ContData.env$myFormat.DateTime)
  myTimeDiff.all <- difftime(myT[-1],myT[-length(myT)],units="mins")
  myTimeDiff <- median(as.vector(myTimeDiff.all),na.rm=TRUE)

  cat(paste("\n\n**Period of Record, Actual:**"
            ,min(data.import[,ContData.env$myName.Date])
            ," to "
            ,max(data.import[,ContData.env$myName.Date])
            ,"\n\n"
            ,sep=""))
       
  cat(paste("**Recording Interval:** ",myTimeDiff[1]," minutes\n\n",sep=""))
  
  if(exists("strFile.DataType")==TRUE){
    myDataType <- strFile.DataType
  } else {
    myDataType <- "NA"
  }
  cat(paste("**Data Type:** ",myDataType,"\n\n",sep=""))  # need to do better
  
   myParameters.ALL     <- ContData.env$myNames.DataFields[ContData.env$myNames.DataFields 
                                                           %in% names(data.import)==TRUE] 
   myParameters.Lab.ALL <- ContData.env$myNames.DataFields.Lab[ContData.env$myNames.DataFields 
                                                               %in% names(data.import)==TRUE]
   # Filter out Discrete
   myParameters     <- myParameters.ALL[!grepl(ContData.env$myPrefix.Discrete,myParameters.ALL)]
   myParameters.Lab <- myParameters.Lab.ALL[
                                           !grepl(ContData.env$myPrefix.Discrete
                                                   ,myParameters.Lab.ALL)]
   
   
 #cat("**Parameters:** ",paste(myParameters.Lab,", ",sep=""),"\n\n",sep="")
  # above line not working, preventing pandoc conversion to WORD
  #cat("**Included Parameters:** \n\n")
  cat("**Parameters Included:** ",paste(myParameters.ALL
                                        ,", "
                                        ,sep="")
      ,"\n\n"
      ,sep="")
```

# DATA SUMMARY, OVERALL

```{r data_summary_overall, results='asis',echo=FALSE, warning=FALSE}
#     2.1. Records by Month/Day
#     split so easier to put on paper
#     number of records by month/day (split 1:15 and 16:31)
#     
  # format = markdown/pandoc = seems to be the same.  All rows but no columns in Word.
  # Have to use on table not ftable.  ftable better by itself but doesn't work with knitr::kable.

    # # QC, if days less than count = 15
    #*Error in table.  Only printing half.* (fixed for sites with <15 days)
    # if((max(data.import[,"day"])-min(data.import[,"day"]))<15) {##IF.daycount.START
    #   myTable <- table(data.import[,"month"],data.import[,"day"])
    #   print(knitr::kable(myTable, format="markdown",row.names=TRUE))
    # } else {
    #   #
    #   #myTable.month.day.rec.LTE15 <-
    #   myTable <- table(data.import[,"month"][data.import[,"day"]<=15],data.import[,"day"][data.import[,"day"]<=15])
    #     print(knitr::kable(myTable, format="markdown", row.names=TRUE))
    #     #knitr::kable(myTable.month.day.rec.LTE15, format="pandoc", caption = "Title of the table")
    #   cat("\n\n")  
    #   #   
    #   # myTable.month.day.rec.GT15 <-
    #   myTable <- table(data.import[,"month"][data.import[,"day"]>15],data.import[,"day"][data.import[,"day"]>15])
    #     print(knitr::kable(myTable, format="markdown", row.names=TRUE))
      #   
   # }##IF.daycount.END


      # Convert time interval (minutes) to number per day
      records.expected <- round(24*60/as.numeric(myTimeDiff[1]),1)
      
      cat(paste("Estimated number of records per day is ",records.expected,".",sep=""))
        cat("\n\n")

        
    cat("Number of records by year and month (with totals).")
    cat("\n")
    myTable <- addmargins(table(data.import[,ContData.env$myName.Yr],data.import[,ContData.env$myName.Mo]))
        print(knitr::kable(myTable, format="markdown", row.names=TRUE))
    cat("\n\n")

    
  # revert to longer table (20170228)
    cat("Number of records by day and month (with totals).")
    cat("\n")
    myTable <- addmargins(table(data.import[,ContData.env$myName.Day],data.import[,ContData.env$myName.Mo]))
        print(knitr::kable(myTable, format="markdown", row.names=TRUE))
    cat("\n\n") 

#     
#     pandoc.table(myTable.month.day.rec.GT15,style="rmarkdown")
#    
#     
    myTable.month.day.rec <- table(data.import[,ContData.env$myName.Mo],data.import[,ContData.env$myName.Day])
#     use apply function to count number of records not equal to the expected value
    cat("\n\n")
    

    #
    myTable.DateTime.N <- aggregate(data.import[,ContData.env$myName.SiteID]  
                                    ~ data.import[,ContData.env$myName.DateTime]
                                    , data=data.import,FUN=length)
    # myTable <- myTable.DateTime.N[myTable.DateTime.N[,ContData.env$myName.SiteID]!=1,]
    # cat(paste0("Date and time records with more than one entry; N=",nrow(myTable),". Duplicate date.time records are shown below."))
    # cat("\n")
    #   print(knitr::kable(myTable, format="markdown", row.names=TRUE))
    # mask error, 20170307
    
    # Missing Dates
    
    myDateRange.Data <- seq(as.Date(min(data.import[,ContData.env$myName.Date]))
                            ,as.Date(max(data.import[,ContData.env$myName.Date]))
                            ,by="day")
    
    if(exists("fun.myData.DateRange.Start")==TRUE){
      myDateRange.Target <- seq(as.Date(fun.myData.DateRange.Start)
                              ,as.Date(fun.myData.DateRange.End)
                              ,by="day")
    } else {
      myDateRange.Target <- myDateRange.Data
    }
    
    myDateRange.Target.Missing <- myDateRange.Target[!myDateRange.Target %in% myDateRange.Data]
    cat(paste0("Below are the dates with missing data between the min (",min(myDateRange.Data)
               ,") and max(",max(myDateRange.Data)," for the provided data. There are "
               ,length(myDateRange.Target.Missing)," records."))
    cat("\n\n")
    print(ifelse(length(myDateRange.Target.Missing)==0,"",myDateRange.Target.Missing))

```


# FLAGS
Each deployment start data point is checked by the two QC tests below. 

* **Spike Test (Spike):** Test if data point exceeds a user defined threshold relative to the previous data point.  The user defined values are based on the parameter being measured.
* **Rate of Change Test (RoC):** Test if a data point exceeds a number of standard deviations from the previous data points over a user defined time period.  Default is a 25 hour time period and 3 standard deviations.

# DEPLOYMENT COMPARISON, BY PARAMETER
```{r CompDeploy, eval=TRUE, echo=TRUE}

fun.col.Param <- "Water.Temp.C"
fun.CompHours <- 25
fun.CompHoursMax <- 12
fun.logdeploy.start <- "start"
fun.logdeploy.end = "end"
fun.col.DateTime = "Date.Time"
fun.col.logdeploy <- "Logger.Deployment"

# may just run an RMD as a Log file.  Nothing else is saved.

logdeploy.terms <- c(fun.logdeploy.start, fun.logdeploy.end)

col2keep <- c(fun.col.DateTime, fun.col.Param, fun.col.logdeploy)

df <- read.csv(file.path(tempdir(), "Data3_Aggregated", "DATA_test2_Aw_20130101_20141231.csv"))

#df[, fun.col.DateTime] <- as.POSIXlt(df[, fun.col.DateTime])


df_small <- df[df[, fun.col.logdeploy] %in% c(logdeploy.terms), col2keep]

n_start <- sum(df[, fun.col.logdeploy] == fun.logdeploy.start, na.rm = TRUE)
n_end   <- sum(df[, fun.col.logdeploy] == fun.logdeploy.end, na.rm = TRUE)
n_deploy <- min(n_start, n_end)
msg <- paste0("Number of deployments identified = ", n_deploy)
message(msg)

date_start <- df_small[df_small[, fun.col.logdeploy] == fun.logdeploy.start, fun.col.DateTime]
date_end <- df_small[df_small[, fun.col.logdeploy] == fun.logdeploy.end, fun.col.DateTime]

# Create deployment comps
# Loop through n_deploy
# will have one less comparison then the number of deployments

for(i in seq_len(n_deploy)) {
  i_A_end <- as.POSIXlt(date_end[i])
  i_B_start <- as.POSIXlt(date_start[i + 1])

  i_A_start <- i_A_end - (fun.CompHours * 3600)
  i_B_end   <- i_B_start + (fun.CompHours * 3600)


  # Compare time
  i_diff <- as.vector(difftime(i_B_start, i_A_end, units = "hours"))
  # QC, stop if gap too large
  if(i_diff > fun.CompHoursMax){
    msg <- paste0("Time difference between end of deployment "
                  , i
                  , " and start of deployment "
                  , i + 1
                  , " is too large ("
                  , i_diff
                  , " hours).")
    message(msg)
    next
  }## IF ~ i_diff ~ END
  
  col_Comp <- "Comp"

  # Identify the range to examine
  df$Comp <- "X"
  mark_A <- df$Date.Time > i_A_start & df$Date.Time <= i_A_end
  mark_B <- df$Date.Time >= i_B_start & df$Date.Time < i_B_end
  df[mark_A, col_Comp] <- "A"
  df[mark_B, col_Comp] <- "B"

  # Loop through parameters
  
  # get data for comparison
  vec_A <- df[df[, col_Comp] == "A", fun.col.Param]
  vec_B <- df[df[, col_Comp] == "B", fun.col.Param]

  # Comment out t test
  # Run function
  #rquery.t.test(vec_A, vec_B, paired = TRUE)
  # wilcoxon test
  #wilcox.test(vec_A, vec_B, paired = TRUE)
  
  col4plot <- c("SiteID", "Date.Time", fun.col.Param, col_Comp)
  
  df_plot <- df[df[, col_Comp] %in% c("A", "B"), col4plot]

  # Spike test
  
  
  lab.title <- paste0("Deployment end/start comparison; ", i_A_end)
  lab.subtitle <- paste0(i, " (A) and ", i+1, " (B)")

  # Plot, box
  p_box <- ggplot(df_plot, aes_string(x = col_Comp
                                      , y = fun.col.Param
                                      , fill = col_Comp)) + 
    geom_boxplot() + 
    labs(title = lab.title
        , subtitle = lab.subtitle
        , x = "Deployments") + 
    theme_bw() +
    theme(legend.position = "none") 
  
  # Plot, time series
  x_vline <- 51 # (i_A_end + i_B_start)/2
  
  p_scat <- ggplot(df_plot, aes_string(x = fun.col.DateTime
                                      , y = fun.col.Param
                                      , color = col_Comp)) +
      geom_point() + 
      geom_vline(xintercept = 50.5) + 
      labs(title = lab.title, subtitle = lab.subtitle) +
      theme_minimal() +
      theme(legend.title = element_blank())
  


}## FOR ~ i ~ END
```



```{r qc_tests_parameters}
 # 3. Data Info, by Parameter
    # Individual Data Type Report
    # QC
    #i <- myParameters[1]

     for (i in myParameters) {##FOR.i.START
#       #
       i.num <- match(i,myParameters)
       myTitle.Sub <- myParameters.Lab[i.num]
       
       
      cat("## QC TESTS, ",i,"\n\n",sep="")
       
       #cat(paste("**QC TESTS,",myTitle.Sub,sep=""))
       
       # 3.1. Flags, overall
       cat(myTitle.Sub <- "### Flags")
             cat("\n\n")
      cat("#### Flag summary, overall number of records.")
      cat("\n\n")
       myTable <- addmargins(table(data.import[,paste("Flag",i,sep=".")]),1)
       print(knitr::kable(t(as.matrix(myTable)), format = "markdown"))
      
      cat("\n\n")
       
      #
      # 3.1. Number of Records (revised 20170228)
       # Convert time interval (minutes) to number per day
      records.expected <- round(24*60/as.numeric(myTimeDiff[1]),1)
      cat(paste("Estimated number of records per day is ",records.expected,".",sep=""))
      cat("\n\n")
      #
      cat("Number of records by year and month (with totals)")
      cat("\n")
      myTable <- addmargins(table(data.import[,ContData.env$myName.Yr],data.import[,ContData.env$myName.Mo]))
      print(knitr::kable(myTable, format="markdown", row.names=TRUE))
      cat("\n\n")
      #
      cat("Number of records by day and month (with totals)")
      cat("\n")
      myTable <- addmargins(table(data.import[,ContData.env$myName.Day],data.import[,ContData.env$myName.Mo]))
      print(knitr::kable(myTable, format="markdown", row.names=TRUE))
      cat("\n\n") 
      #
      # identify days/months where not the expected number of records
      # (expect first and last day)
  #    print("days where not the expected number of records")
      #
      # 3.2. Flags by QC Test
      
      cat("\n\n")
      
      cat("#### Flags by QC Test")
      
      cat("\n\n")
      
      cat("##### Flags, Gross\n\n")
      
      myTable <- addmargins(table(data.import[,paste(ContData.env$myName.Flag,"Gross",i,sep=".")]),1)
      print(knitr::kable(t(as.matrix(myTable)), format = "markdown"))
        cat("\n\n")
      cat("##### Flags, Spike\n\n")
      
      myTable <- addmargins(table(data.import[,paste(ContData.env$myName.Flag,"Spike",i,sep=".")]),1)
      print(knitr::kable(t(as.matrix(myTable)), format = "markdown"))
        cat("\n\n")
      cat("##### Flags, RoC\n\n")
      
      myTable <- addmargins(table(data.import[,paste(ContData.env$myName.Flag,"RoC",i,sep=".")]),1)
      print(knitr::kable(t(as.matrix(myTable)), format = "markdown"))
        cat("\n\n")
      cat("##### Flags, Flat\n\n")
      
      myTable <- addmargins(table(data.import[,paste(ContData.env$myName.Flag,"Flat",i,sep=".")]),1)
      print(knitr::kable(t(as.matrix(myTable)), format = "markdown"))
        cat("\n\n")
      cat("QC Test Flag fields are saved in the data file so the user can identify data points that have been flagged as suspect or fail.")
     
      #
      #myFlagTests <- c("Gross","Spike","RoC","Flat")
      #(myTable.Flags.Flat <- ftable(data.import[,paste("Flag",myFlagTests,i,sep=".")]))
      #
      
      
      cat(paste("\n\n Test results marked as ",ContData.env$myFlagVal.NoData," (No/Missing Data) if unable to calculate the end point needed for the test.  For example, the first record does not have a previous record for comparison for the Gross QC Test.  QC Test flags are saved in the data file.",sep=""))
      
      #
      # 3.3. Plot
      data.plot <- data.import
      #
      plot_format <- "ggplot" # "base" or "ggplot"
      #
      if(plot_format=="base"){##IF~plot_format~START
        # plot, base ####
         # cheat on Date/Time axis
        n.Total <- length(data.plot[,ContData.env$myName.Date])
        pct <- c(20,40,60,80,100)*.01
        myAT <- c(1,round(n.Total * pct,0))
        myLab <- data.plot[,ContData.env$myName.Date][myAT]
        #
        myPlot.Y <- na.omit(as.numeric(data.plot[,i])) 
        #20170518, v2.0.1.9008, coming in as text add na.omit(as.numeric(x))
        myPlot.Ylab <- myParameters.Lab[i.num]
        plot(myPlot.Y,type="l",main=mySiteID,xlab=ContData.env$myLab.Date
             ,ylab=myPlot.Ylab,col="gray", xaxt="n")
        axis(1,at=myAT,labels=myLab,tick=TRUE)
        # Add discrete (only if present)
        myDiscrete <- paste(ContData.env$myPrefix.Discrete,i,sep=".")
        if (myDiscrete %in% myParameters.ALL == TRUE){##IF.Discrete.START
          data.plot[,myDiscrete] <- as.numeric(data.plot[,myDiscrete]) # coerce "NA" to NA
          data.plot.points <- na.omit(data.plot[,c(ContData.env$myName.DateTime,myDiscrete)]) 
          # remove NA
          myPoints.X <- as.numeric(rownames(data.plot.points))
          myPoints.Y <- data.plot.points[,myDiscrete]
          points(myPoints.Y~myPoints.X,col="black",pch=19) 
        }##IF.Discrete.END
        cat("\n\n")
        cat("Discrete measurements, if any, show up as points on the plot.")
        cat("\n\n")
      } else if(plot_format=="ggplot"){
        # plot, ggplot ####
        data.plot[, ContData.env$myName.DateTime] <- as.POSIXct(data.plot[, ContData.env$myName.DateTime])
        # ggplot, main
        scale_lab   <- c("Continuous", "Discrete")
        scale_col   <- c("dark gray", "black")
        scale_shape <- c(21, 24)
        scale_fill  <- scale_col
        p_i <- ggplot2::ggplot(data=data.plot, ggplot2::aes_string(x=ContData.env$myName.DateTime, y=i)) +
                ggplot2::geom_point(ggplot2::aes(color="continuous"
                                                 , shape="continuous"
                                                 , fill="continuous"), na.rm=TRUE) + 
                ggplot2::scale_x_datetime(date_labels = "%Y-%m-%d") + 
                ggplot2::labs(title=mySiteID, x=ContData.env$myLab.Date, y=myParameters.Lab[i.num]) +
                ggplot2::theme(plot.title=ggplot2::element_text(hjust=0.5)
                               , plot.subtitle=ggplot2::element_text(hjust=0.5))
        # ggplot, discrete points
        # Add discrete (only if present)
        myDiscrete <- paste(ContData.env$myPrefix.Discrete,i,sep=".")
        if (myDiscrete %in% myParameters.ALL == TRUE){##IF.Discrete.START
          p_i <- p_i + ggplot2::geom_point(data=data.plot
                                           , ggplot2::aes_q(x=as.name(ContData.env$myName.DateTime)
                                                            , y=as.name(myDiscrete)
                                                            , color="discrete"
                                                            , shape="discrete"
                                                            , fill="discrete"), na.rm=TRUE) 
        } else {
         p_i <- p_i + ggplot2::geom_blank(ggplot2::aes(color="discrete"
                                                       , shape="discrete"
                                                       , fill="discrete"))
        }##IF.Discrete.END
        # ggplot, Legend
        p_i <- p_i + 
                ggplot2::scale_color_manual(name="Data Type", labels=scale_lab, values=scale_col) +
                ggplot2::scale_shape_manual(name="Data Type", labels=scale_lab, values=scale_shape) +
                ggplot2::scale_fill_manual(name="Data Type", labels=scale_lab, values=scale_fill) 
        # ggplot, show 
        print(p_i)
        cat("\n\n")
      }##IF~plot_format~END
     

      
      #
    }##FOR.i.END

```



