myMsg <- "SKIPPED (Missing Fields, Date/Time)"
myItems.Skipped <- myItems.Skipped + 1
myItems.Log[intCounter,2] <- myMsg
fun.write.log(myItems.Log,myDate,myTime)
fun.Msg.Status(myMsg, intCounter, intItems.Total, strFile)
flush.console()
# go to next Item
next
}
# go to next item if no (date or time) AND no date/time field  (i.e., only 1 of date or time)
if(length(strCol.DT.Missing)==2 & ContData.env$myName.DateTime%in%strCol.DT.Missing==TRUE) {
myMsg <- "SKIPPED (Missing Fields, 'Date.Time' and one of 'Date' or 'Time')"
myItems.Skipped <- myItems.Skipped + 1
myItems.Log[intCounter,2] <- myMsg
fun.write.log(myItems.Log,myDate,myTime)
fun.Msg.Status(myMsg, intCounter, intItems.Total, strFile)
flush.console()
# go to next Item
next
}
#
# add to df
data.import[,strCol.DT.Missing] <- NA
#
strFile = files2process[intCounter]
strFile.Base <- substr(strFile,1,nchar(strFile)-nchar(".csv"))
strFile.parts <- strsplit(strFile.Base, ContData.env$myDelim)
strFile.SiteID     <- strFile.parts[[1]][1]
source("./R/config.R")
source("./R/fun.Helper.R")
source("./R/fun.DateFormat.R")
# B.1.0. File Name, Define
strFile = files2process[intCounter]
# 1.1. File Name, Parse
strFile.Base <- substr(strFile,1,nchar(strFile)-nchar(".csv"))
strFile.parts <- strsplit(strFile.Base, ContData.env$myDelim)
strFile.SiteID     <- strFile.parts[[1]][1]
strFile.DataType   <- strFile.parts[[1]][2]
# Convert Data Type to proper case
strFile.DataType <- paste(toupper(substring(strFile.DataType,1,1)),tolower(substring(strFile.DataType,2,nchar(strFile.DataType))),sep="")
strFile.Date.Start <- as.Date(strFile.parts[[1]][3],"%Y%m%d")
strFile.Date.End   <- as.Date(strFile.parts[[1]][4],"%Y%m%d")
#
# B.2.1. Check File Size
if(file.info(paste(myDir.data.import,"/",strFile,sep=""))$size==0){
# inform user of progress and update LOG
myMsg <- "SKIPPED (file blank)"
myItems.Skipped <- myItems.Skipped + 1
myItems.Log[intCounter,2] <- myMsg
fun.write.log(myItems.Log,myDate,myTime)
fun.Msg.Status(myMsg, intCounter, intItems.Total, strFile)
flush.console()
# go to next Item
next
}
# B.2.2. Check SiteID
# if not in provided site list then skip
if(strFile.SiteID %in% fun.myData.SiteID == FALSE) {
# inform user of progress and update LOG
myMsg <- "SKIPPED (Non-Match, SiteID)"
myItems.Skipped <- myItems.Skipped + 1
myItems.Log[intCounter,2] <- myMsg
fun.write.log(myItems.Log,myDate,myTime)
fun.Msg.Status(myMsg, intCounter, intItems.Total, strFile)
flush.console()
# go to next Item
next
}
# B.2.3. Check DataType
# if not equal go to next file (handles both Air and Water)
if (strFile.DataType %in% fun.myData.Type == FALSE){
# inform user of progress and update LOG
myMsg <- "SKIPPED (Non-Match, DataType)"
myItems.Skipped <- myItems.Skipped + 1
myItems.Log[intCounter,2] <- myMsg
fun.write.log(myItems.Log,myDate,myTime)
fun.Msg.Status(myMsg, intCounter, intItems.Total, strFile)
flush.console()
# go to next Item
next
}
# B.2.4. Check Dates
# B.2.4.2.1. Check File.Date.Start (if file end < my Start then next)
if(strFile.Date.End<fun.myData.DateRange.Start) {
# inform user of progress and update LOG
myMsg <- "SKIPPED (Non-Match, Start Date)"
myItems.Skipped <- myItems.Skipped + 1
myItems.Log[intCounter,2] <- myMsg
fun.write.log(myItems.Log,myDate,myTime)
fun.Msg.Status(myMsg, intCounter, intItems.Total, strFile)
flush.console()
# go to next Item
next
}
# B.2.4.2.2. Check File.Date.End (if file Start > my End then next)
if(strFile.Date.Start>fun.myData.DateRange.End) {
# inform user of progress and update LOG
myMsg <- "SKIPPED (Non-Match, End Date)"
myItems.Skipped <- myItems.Skipped + 1
myItems.Log[intCounter,2] <- myMsg
fun.write.log(myItems.Log,myDate,myTime)
fun.Msg.Status(myMsg, intCounter, intItems.Total, strFile)
flush.console()
# go to next Item
next
}
#
# B.3.0. Import the data
#data.import=read.table(strFile,header=F,varSep)
#varSep = "\t" (use read.delim instead of read.table)
# as.is = T so dates come in as text rather than factor
#data.import <- read.delim(strFile,as.is=TRUE,na.strings="")
data.import <- read.csv(paste(myDir.data.import,strFile,sep="/"),as.is=TRUE,na.strings="")
#
# QC required fields: SiteID & (DateTime | (Date & Time))
fun.QC.ReqFlds(names(data.import),paste(myDir.data.import,strFile,sep="/"))
#
# B.4.0. Columns
# Kick out if missing minimum of fields
#
# Check for and add any missing columns (but not for missing data fields)
# B.4.1. Date, Time, DateTime
# list
strCol.DT <- c(ContData.env$myName.Date,ContData.env$myName.Time,ContData.env$myName.DateTime)
# check for missing
strCol.DT.Missing <- strCol.DT[strCol.DT %in% colnames(data.import)==FALSE]
# go to next item if no date, time, or date/time field
if(length(strCol.DT.Missing)==3) {
myMsg <- "SKIPPED (Missing Fields, Date/Time)"
myItems.Skipped <- myItems.Skipped + 1
myItems.Log[intCounter,2] <- myMsg
fun.write.log(myItems.Log,myDate,myTime)
fun.Msg.Status(myMsg, intCounter, intItems.Total, strFile)
flush.console()
# go to next Item
next
}
# go to next item if no (date or time) AND no date/time field  (i.e., only 1 of date or time)
if(length(strCol.DT.Missing)==2 & ContData.env$myName.DateTime%in%strCol.DT.Missing==TRUE) {
myMsg <- "SKIPPED (Missing Fields, 'Date.Time' and one of 'Date' or 'Time')"
myItems.Skipped <- myItems.Skipped + 1
myItems.Log[intCounter,2] <- myMsg
fun.write.log(myItems.Log,myDate,myTime)
fun.Msg.Status(myMsg, intCounter, intItems.Total, strFile)
flush.console()
# go to next Item
next
}
#
# add to df
data.import[,strCol.DT.Missing] <- NA
#
# B.4.2.  Check for columns present and reorder columns
# check for columns present
strCol.Present <- ContData.env$myNames.Order[ContData.env$myNames.Order %in% colnames(data.import)==TRUE]
#
myNames.DataFields.Present <- ContData.env$myNames.DataFields[ContData.env$myNames.DataFields %in% colnames(data.import)==TRUE]
# kick out if no data fields
if(length(myNames.DataFields.Present)==0){
myMsg <- "SKIPPED (Missing Fields, DATA)"
myItems.Skipped <- myItems.Skipped + 1
myItems.Log[intCounter,2] <- myMsg
fun.write.log(myItems.Log,myDate,myTime)
fun.Msg.Status(myMsg, intCounter, intItems.Total, strFile)
flush.console()
# go to next Item
}
#
# reorder Columns (and drop extra columns)
data.import <- data.import[,strCol.Present]
# B.4.3. Add FLAGS
strCol.Flags <- ContData.env$myNames.Flags[ContData.env$myNames.Cols4Flags %in% colnames(data.import)==TRUE]
data.import[,strCol.Flags] <- ""
#
#
# data columns for flags that are present (need for later)
#myNames.Cols4Flags.Present <- myNames.Cols4Flags[myNames.Cols4Flags %in% colnames(data.import)==TRUE]
#
#~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
# get format - if all data NA then get an error
#
# backfill first?
#
# may have to add date and time (data) from above when add the missing field.
#if does not exists then add field and data.
#
# if entire field is NA then fill from other fields
# Date
myField   <- ContData.env$myName.Date
data.import[,myField][all(is.na(data.import[,myField]))] <- data.import[,ContData.env$myName.DateTime]
# Time
myField   <- ContData.env$myName.Time
data.import[,myField][all(is.na(data.import[,myField]))] <- data.import[,ContData.env$myName.DateTime]
# DateTime
#myField   <- myName.DateTime
# can't fill fill from others without knowing the format
#
# get current file date/time records so can set format
# Function below gets date or time format and returns R format
# date_time is split and then pasted together.
# if no AM/PM then 24hr time is assumed
format.Date     <- fun.DateTimeFormat(data.import[,ContData.env$myName.Date],"Date")
format.Time     <- fun.DateTimeFormat(data.import[,ContData.env$myName.Time],"Time")
#format.DateTime <- fun.DateTimeFormat(data.import[,ContData.env$myName.DateTime],"DateTime")
# get error if field is NA, need to fix
# same for section below
#
# 20160322, new section, check for NA and fill if needed
if (length(na.omit(data.import[,ContData.env$myName.DateTime]))==0){##IF.DateTime==NA.START
# move 5.2.1 up here
myField   <- ContData.env$myName.DateTime
myFormat  <- ContData.env$myFormat.DateTime #"%Y-%m-%d %H:%M:%S"
#   data.import[,myField][data.import[,myField]==""] <- strftime(paste(data.import[,myName.Date][data.import[,myField]==""]
#                                                                       ,data.import[,myName.Time][data.import[,myField]==""],sep="")
#                                                                 ,format=myFormat,usetz=FALSE)
data.import[,myField][is.na(data.import[,myField])] <- strftime(paste(data.import[,ContData.env$myName.Date][is.na(data.import[,myField])]
,data.import[,ContData.env$myName.Time][is.na(data.import[,myField])]
,sep=" ")
,format=myFormat,usetz=FALSE)
}##IF.DateTime==NA.START
format.DateTime <- fun.DateTimeFormat(data.import[,ContData.env$myName.DateTime],"DateTime")
#
# QC
#  # format.Date <- "%Y-%m-%d"
#   format.Time <- "%H:%M:%S"
#   format.DateTime <- "%Y-%m-%d %H:%M"
#
# B.5. QC Date and Time
# 5.1. Convert all Date_Time, Date, and Time formats to expected format (ISO 8601)
# Should allow for users to use different time and date formats in original data
# almost worked
#data.import[!(is.na(data.import[,myName.DateTime])),][myName.DateTime] <- strftime(data.import[!(is.na(data.import[,myName.DateTime])),][myName.DateTime]
#                                                                                   ,format="%Y-%m-%d")
# have to do where is NOT NA because will fail if the first item is NA
# assume all records have the same format.
#
# B.5.1.1. Update Date to "%Y-%m-%d" (equivalent to %F)
myField   <- ContData.env$myName.Date
myFormat.In  <- format.Date #"%Y-%m-%d"
myFormat.Out <- ContData.env$myFormat.Date #"%Y-%m-%d"
data.import[,myField][!is.na(data.import[,myField])] <- format(strptime(data.import[,myField][!is.na(data.import[,myField])],format=myFormat.In)
,format=myFormat.Out)
# B.5.1.2. Update Time to "%H:%M:%S" (equivalent to %T) (uses different function)
myField   <- ContData.env$myName.Time
myFormat.In  <- format.Time #"%H:%M:%S"
myFormat.Out <- ContData.env$myFormat.Time #"%H:%M:%S"
data.import[,myField][!is.na(data.import[,myField])] <- format(as.POSIXct(data.import[,myField][!is.na(data.import[,myField])],format=myFormat.In)
,format=myFormat.Out)
# B.5.1.3. Update DateTime to "%Y-%m-%d %H:%M:%S" (equivalent to %F %T)
myField   <- ContData.env$myName.DateTime
myFormat.In  <- format.DateTime #"%Y-%m-%d %H:%M:%S"
myFormat.Out <- ContData.env$myFormat.DateTime #"%Y-%m-%d %H:%M:%S"
data.import[,myField][!is.na(data.import[,myField])] <- format(strptime(data.import[,myField][!is.na(data.import[,myField])],format=myFormat.In)
,format=myFormat.Out)
#   # strptime adds the timezome but drops it when added back to data.import (using format)
#~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
#   # doesn't work anymore, worked when first line was NA
#~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
#   data.import <- y
#   x<-data.import[,myField][!is.na(data.import[,myField])]
#   (z<-x[2])
#   (a <- strptime(z,format=myFormat.In))
#   (b <- strptime(x,format=myFormat.In))
#   # works on single record but fails on vector with strftime
#   # strptime works but adds time zone (don't like but it works)
#
#
# B.5.2. Update DateTime, Date, and Time if NA based on other fields
# B.5.2.1. Update Date_Time if NA (use Date and Time)
myField   <- ContData.env$myName.DateTime
myFormat  <- ContData.env$myFormat.DateTime #"%Y-%m-%d %H:%M:%S"
#   data.import[,myField][data.import[,myField]==""] <- strftime(paste(data.import[,myName.Date][data.import[,myField]==""]
#                                                                       ,data.import[,myName.Time][data.import[,myField]==""],sep="")
#                                                                 ,format=myFormat,usetz=FALSE)
data.import[,myField][is.na(data.import[,myField])] <- strftime(paste(data.import[,ContData.env$myName.Date][is.na(data.import[,myField])]
,data.import[,ContData.env$myName.Time][is.na(data.import[,myField])]
,sep=" ")
,format=myFormat,usetz=FALSE)
# B.5.2.2. Update Date if NA (use Date_Time)
myField   <- ContData.env$myName.Date
myFormat  <- ContData.env$myFormat.Date #"%Y-%m-%d"
#   data.import[,myField][data.import[,myField]==""] <- strftime(data.import[,myName.DateTime][data.import[,myName.Date]==""]
#                                                               ,format=myFormat,usetz=FALSE)
data.import[,myField][is.na(data.import[,myField])] <- strftime(data.import[,ContData.env$myName.DateTime][is.na(data.import[,myField])]
,format=myFormat,usetz=FALSE)
# B.5.2.3. Update Time if NA (use Date_Time)
myField   <- ContData.env$myName.Time
myFormat  <- ContData.env$myFormat.Time #"%H:%M:%S"
#   data.import[,myField][data.import[,myField]==""] <- strftime(data.import[,myName.DateTime][data.import[,myName.Time]==""]
#                                                               ,format=myFormat,usetz=FALSE)
data.import[,myField][is.na(data.import[,myField])] <- as.POSIXct(data.import[,ContData.env$myName.DateTime][is.na(data.import[,myField])]
,format=myFormat,usetz=FALSE)
#
# old code just for reference
# B.5.5. Force Date and Time format
#   data.import[,myName.Date] <- strftime(data.import[,myName.Date],format="%Y-%m-%d")
#   data.import[,myName.Time] <- as.POSIXct(data.import[,myName.Time],format="%H:%M:%S")
#   data.import[,myName.DateTime] <- strftime(data.import[,myName.DateTime],format="%Y-%m-%d %H:%M:%S")
#
#
# Create Month and Day Fields
# month
#     myField   <- "month"
#     data.import[,myField] <- data.import[,myName.Date]
#     myFormat  <- "%m"
#     data.import[,myField][!is.na(data.import[,myName.Date])] <- strftime(data.import[,myName.Date][!is.na(data.import[,myName.DateTime])]
#                                                                     ,format=myFormat,usetz=FALSE)
data.import[,ContData.env$myName.Mo] <- as.POSIXlt(data.import[,ContData.env$myName.Date])$mon+1
# day
#     myField   <- "day"
#     data.import[,myField] <- data.import[,myName.Date]
#     myFormat.In  <- myFormat.Date #"%Y-%m-%d"
#     myFormat.Out <- "%d"
#     data.import[,myField][!is.na(data.import[,myField])] <- format(strptime(data.import[,myField][!is.na(data.import[,myField])],format=myFormat.In)
#                                                                    ,format=myFormat.Out)
data.import[,ContData.env$myName.Day] <- as.POSIXlt(data.import[,ContData.env$myName.Date])$mday
# year
data.import[,ContData.env$myName.Yr] <- as.POSIXlt(data.import[,ContData.env$myName.Date])$year+1900
#
#     # example of classes for POSIXlt
#     Sys.time()
#     unclass(as.POSIXlt(Sys.time()))
#     ?DateTimeClasses
#
# B.6. QC for each Data Type present ####
# sub routine adds QC Calcs, QC Test Flags, Assigns overall Flag, and removes QC Calc Fields
# cycle each data type (manually code)
#
# skip if not present
# 20170512, move message inside of IF so user doesn't see it.
#
myField <- ContData.env$myName.WaterTemp
myField %in% myNames.DataFields.Present==TRUE
myMsg.data <- "WaterTemp"
myMsg <- paste("WORKING (QC Tests and Flags - ",myMsg.data,")",sep="")
myItems.Complete <- myItems.Complete + 1
myItems.Log[intCounter,2] <- myMsg
fun.Msg.Status(myMsg, intCounter, intItems.Total, strFile)
flush.console()
fun.data.import <- data.import
myField <- ContData.env$myName.WaterTemp
fun.myField.Data <- myField
fun.myThresh.Gross.Fail.Hi <- ContData.env$myThresh.Gross.Fail.Hi.WaterTemp
fun.myThresh.Gross.Fail.Lo <- ContData.env$myThresh.Gross.Fail.Lo.WaterTemp
fun.myThresh.Gross.Suspect.Hi <- ContData.env$myThresh.Gross.Suspect.Hi.WaterTemp
fun.myThresh.Gross.Suspect.Lo <- ContData.env$myThresh.Gross.Suspect.Lo.WaterTemp
fun.myThresh.Spike.Hi <- ContData.env$myThresh.Spike.Hi.WaterTemp
fun.myThresh.Spike.Lo <- ContData.env$myThresh.Spike.Lo.WaterTemp
fun.myThresh.RoC.SD.period <- ContData.env$myThresh.RoC.SD.period.WaterTemp
fun.myThresh.RoC.SD.number <- ContData.env$myThresh.RoC.SD.number.WaterTemp
fun.myThresh.Flat.Hi <- ContData.env$myThresh.Flat.Hi.WaterTemp
fun.myThresh.Flat.Lo <- ContData.env$myThresh.Flat.Lo.WaterTemp
fun.myThresh.Flat.Tolerance <- ContData.env$myThresh.Flat.Tolerance.WaterTemp
fun.myField.Data.ALL <- names(fun.data.import)[names(fun.data.import) %in% ContData.env$myNames.DataFields]
boo.Offset <- fun.OffsetCollectionCheck(fun.data.import, fun.myField.Data.ALL, ContData.env$myName.DateTime)
boo.Offset
if(boo.Offset==TRUE) {##IF.boo.Offset.START
# check time interval (na.omit removes all)
df.check <- na.omit(fun.data.import[,c(ContData.env$myName.DateTime,fun.myField.Data)])
# convert from Character to time if necessary (not necessary)
# if (is.character(df.check[,ContData.env$myName.DateTime])==TRUE){
#   myFormat  <- ContData.env$myFormat.DateTime #"%Y-%m-%d %H:%M:%S"
#   # df.check[,ContData.env$myName.DateTime] <- strftime(df.check[,ContData.env$myName.DateTime],
#   #                                                     format=myFormat,
#   #                                                     tz=ContData.env$myTZ)
# }
x <- df.check[,ContData.env$myName.DateTime]
myTimeDiff.all <- difftime(x[-1],x[-length(x)])
myTimeDiff <- median(as.vector(myTimeDiff.all))
# create time series
myTS <- seq(as.POSIXlt(min(x),tz=ContData.env$myTZ),as.POSIXlt(max(x),tz=ContData.env$myTZ),by="30 min") #by=paste0(myTimeDiff," min"))
length(myTS)
#~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
# remove other data fields (and extra times) before proceeding
### Fields to keep
myFlds.Keep <- c(ContData.env$myName.SiteID,
ContData.env$myName.DateTime, ContData.env$myName.Date, ContData.env$myName.Time,
ContData.env$myName.Mo, ContData.env$myName.Day, ContData.env$myName.Yr,
fun.myField.Data, paste0(ContData.env$myName.Flag,".",fun.myField.Data))
### Modify the DF
# keep only the relevant data field and remove all NA (case-wise)
fun.data.import.mod <- na.omit(fun.data.import[,myFlds.Keep])
#~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
# Check length.  If different add in extra times
## NA records would have been removed earlier
if (length(myTS) != nrow(df.check)){##IF.length.START
# add extra rows to new Time Series
ts.alltimes <- as.data.frame(as.character(myTS))
names(ts.alltimes) <- ContData.env$myName.DateTime
# merge (works with datetime as character but not as a POSIX field)
#df.check[,ContData.env$myName.DateTime] <- as.POSIXlt(df.check[,ContData.env$myName.DateTime],origin = "1900-01-01",tz=ContData.env$myTZ)
ts.alltimes.data <- merge(ts.alltimes, fun.data.import.mod, by=ContData.env$myName.DateTime)
# use new df moving forward
fun.data.import.mod <- ts.alltimes.data
}##IF.length.END
# then merge back at end
} else {
# rename fun.data.import (for non Offset)
fun.data.import.mod <- fun.data.import
}##IF.boo.Offset.END
myCalc <- "SD.Time"
myField <- paste(fun.myField.Data,myCalc,sep=".")
myT <- strptime(fun.data.import.mod[,ContData.env$myName.DateTime],format=ContData.env$myFormat.DateTime)
myT$hour <- myT$hour - fun.myThresh.RoC.SD.period
fun.data.import.mod[,myField] <- as.character(myT)
myField.T1 <- myField
myCalc <- "SD"
myField <- paste(fun.myField.Data,myCalc,sep=".")
if(nrow(fun.data.import.mod)<5) {##IF.nrow.START
myMsg <- paste("\n
The data file has less than 5 records.
The scripts will not work properly until you have more data."
,sep="")
stop(myMsg)
}##IF.1.END
x <- fun.data.import.mod[,ContData.env$myName.DateTime]
View(x)
ContData.env$myName.DateTime
View(fun.data.import.mod)
fun.data.import.mod[,ContData.env$myName.DateTime]
x <- fun.data.import.mod[,ContData.env$myName.DateTime]
head(x)
View(x)
x
length(x)
x[-1]
x[1]
x[length(x)]
difftime(x[-1],x[-length(x)], units="mins")
ContDataQC(myData.Operation, myData.SiteID, myData.Type, myData.DateRange.Start, myData.DateRange.End, getwd(), "", "")
setwd(paste0("./",myLibrary))
devtools::document()
setwd("..") # return to root directory first
devtools::install(myLibrary)
library(myLibrary,character.only = TRUE)
setwd(paste0("./",myLibrary))
#~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
# Library Name
myLibrary <- "ContDataQC" # "ContDataQC","MMIcalc","MMIcalcNV","MBSStools","XC95"
# Load Library
library(devtools)
#~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
# Create Package
# create(myLibrary)
#~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
# files to library folder
# file.copy("metric.values.R","./Library/MMIcalc/R/metric.values.R",overwrite=TRUE)
#~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
#
#~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
# Document, Install, and Reload Library
## Generate Documentation
setwd(paste0("./",myLibrary))
library(ContDataQC)
?ContDataQC
# Parameters
Selection.Operation <- c("GetGageData","QCRaw", "Aggregate", "SummaryStats")
Selection.Type      <- c("Air","Water","AW","Gage","AWG","AG","WG")
myData.DateRange.Start  <- "2013-01-01"
myData.DateRange.End    <- "2014-12-31"
Selection.SUB <- c("Data1_RAW","Data2_QC","Data3_Aggregated","Data4_Stats")
myDir.SUB.import <- ""
myDir.SUB.export <- ""
# QC Raw Data
myData.Operation <- "QCRaw" #Selection.Operation[2]
myData.SiteID    <- "test2"
myData.Type      <- Selection.Type[3] #"AW"
myDir.SUB.import <- Selection.SUB[1] #"Data1_RAW"
myDir.SUB.export <- Selection.SUB[2] #"Data2_QC"
ContDataQC(myData.Operation, myData.SiteID, myData.Type, myData.DateRange.Start, myData.DateRange.End, getwd(), "", "")
# declare operation ####
fun.myData.Operation       <- "QCRaw"
fun.myData.SiteID          <- "test4"
fun.myData.Type            <- "Aw"
fun.myData.DateRange.Start <- "2016-04-18"
fun.myData.DateRange.End   <- "2016-07-26"
fun.myDir.BASE             <- getwd()
fun.myDir.SUB.import       <- "Data1_RAW"
fun.myDir.SUB.export       <- "Data2_QC"
# declare operation ####
ContDataQC(fun.myData.Operation, fun.myData.SiteID, fun.myData.Type,
fun.myData.DateRange.Start, fun.myData.DateRange.End,
fun.myDir.BASE = getwd(), fun.myDir.SUB.import = "",
fun.myDir.SUB.export = "")
##~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
# Library Name
myLibrary <- "ContDataQC" # "ContDataQC","MMIcalc","MMIcalcNV","MBSStools","XC95"
# Load Library
library(devtools)
#~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
# Create Package
# create(myLibrary)
#~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
# files to library folder
# file.copy("metric.values.R","./Library/MMIcalc/R/metric.values.R",overwrite=TRUE)
#~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
#
#~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
# Document, Install, and Reload Library
## Generate Documentation
setwd(paste0("./",myLibrary))
devtools::document()
## Install New Package (locally)
setwd("..") # return to root directory first
devtools::install(myLibrary)
## Reload library
library(myLibrary,character.only = TRUE)
# change wd back to package
setwd(paste0("./",myLibrary))
?ContDataQC
library(ContDataQC)
?ContDataQC
