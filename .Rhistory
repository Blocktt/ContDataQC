#~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
# may have to tinker with for NA fields
#~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
# get format - if all data NA then get an error
#
# backfill first?
#
# may have to add date and time (data) from above when add the missing field.
#if does not exists then add field and data.
#
# if entire field is NA then fill from other fields
# Date
myField   <- ContData.env$myName.Date
data.import[,myField][all(is.na(data.import[,myField]))] <- data.import[,ContData.env$myName.DateTime]
# Time
myField   <- ContData.env$myName.Time
data.import[,myField][all(is.na(data.import[,myField]))] <- data.import[,ContData.env$myName.DateTime]
# DateTime
#myField   <- myName.DateTime
# can't fill fill from others without knowing the format
#
# get current file date/time records so can set format
# Function below gets date or time format and returns R format
# date_time is split and then pasted together.
# if no AM/PM then 24hr time is assumed
format.Date     <- fun.DateTimeFormat(data.import[,ContData.env$myName.Date],"Date")
format.Time     <- fun.DateTimeFormat(data.import[,ContData.env$myName.Time],"Time")
#format.DateTime <- fun.DateTimeFormat(data.import[,ContData.env$myName.DateTime],"DateTime")
# get error if field is NA, need to fix
# same for section below
#
# 20160322, new section, check for NA and fill if needed
if (length(na.omit(data.import[,ContData.env$myName.DateTime]))==0){##IF.DateTime==NA.START
# move 5.2.1 up here
myField   <- ContData.env$myName.DateTime
myFormat  <- ContData.env$myFormat.DateTime #"%Y-%m-%d %H:%M:%S"
#   data.import[,myField][data.import[,myField]==""] <- strftime(paste(data.import[,myName.Date][data.import[,myField]==""]
#                                                                       ,data.import[,myName.Time][data.import[,myField]==""],sep="")
#                                                                 ,format=myFormat,usetz=FALSE)
data.import[,myField][is.na(data.import[,myField])] <- strftime(paste(data.import[,ContData.env$myName.Date][is.na(data.import[,myField])]
,data.import[,ContData.env$myName.Time][is.na(data.import[,myField])]
,sep=" ")
,format=myFormat,usetz=FALSE)
}##IF.DateTime==NA.START
format.DateTime <- fun.DateTimeFormat(data.import[,ContData.env$myName.DateTime],"DateTime")
#
# QC
#  # format.Date <- "%Y-%m-%d"
#   format.Time <- "%H:%M:%S"
#   format.DateTime <- "%Y-%m-%d %H:%M"
#
# B.5. QC Date and Time
# 5.1. Convert all Date_Time, Date, and Time formats to expected format (ISO 8601)
# Should allow for users to use different time and date formats in original data
# almost worked
#data.import[!(is.na(data.import[,myName.DateTime])),][myName.DateTime] <- strftime(data.import[!(is.na(data.import[,myName.DateTime])),][myName.DateTime]
#                                                                                   ,format="%Y-%m-%d")
# have to do where is NOT NA because will fail if the first item is NA
# assume all records have the same format.
#
# B.5.1.1. Update Date to "%Y-%m-%d" (equivalent to %F)
myField   <- ContData.env$myName.Date
myFormat.In  <- format.Date #"%Y-%m-%d"
myFormat.Out <- ContData.env$myFormat.Date #"%Y-%m-%d"
data.import[,myField][!is.na(data.import[,myField])] <- format(strptime(data.import[,myField][!is.na(data.import[,myField])],format=myFormat.In)
,format=myFormat.Out)
# B.5.1.2. Update Time to "%H:%M:%S" (equivalent to %T) (uses different function)
myField   <- ContData.env$myName.Time
myFormat.In  <- format.Time #"%H:%M:%S"
myFormat.Out <- ContData.env$myFormat.Time #"%H:%M:%S"
data.import[,myField][!is.na(data.import[,myField])] <- format(as.POSIXct(data.import[,myField][!is.na(data.import[,myField])],format=myFormat.In)
,format=myFormat.Out)
# B.5.1.3. Update DateTime to "%Y-%m-%d %H:%M:%S" (equivalent to %F %T)
myField   <- ContData.env$myName.DateTime
myFormat.In  <- format.DateTime #"%Y-%m-%d %H:%M:%S"
myFormat.Out <- ContData.env$myFormat.DateTime #"%Y-%m-%d %H:%M:%S"
data.import[,myField][!is.na(data.import[,myField])] <- format(strptime(data.import[,myField][!is.na(data.import[,myField])],format=myFormat.In)
,format=myFormat.Out)
#   # strptime adds the timezome but drops it when added back to data.import (using format)
#~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
#   # doesn't work anymore, worked when first line was NA
#~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
#   data.import <- y
#   x<-data.import[,myField][!is.na(data.import[,myField])]
#   (z<-x[2])
#   (a <- strptime(z,format=myFormat.In))
#   (b <- strptime(x,format=myFormat.In))
#   # works on single record but fails on vector with strftime
#   # strptime works but adds time zone (don't like but it works)
#
#
# B.5.2. Update DateTime, Date, and Time if NA based on other fields
# B.5.2.1. Update Date_Time if NA (use Date and Time)
myField   <- ContData.env$myName.DateTime
myFormat  <- ContData.env$myFormat.DateTime #"%Y-%m-%d %H:%M:%S"
#   data.import[,myField][data.import[,myField]==""] <- strftime(paste(data.import[,myName.Date][data.import[,myField]==""]
#                                                                       ,data.import[,myName.Time][data.import[,myField]==""],sep="")
#                                                                 ,format=myFormat,usetz=FALSE)
data.import[,myField][is.na(data.import[,myField])] <- strftime(paste(data.import[,ContData.env$myName.Date][is.na(data.import[,myField])]
,data.import[,ContData.env$myName.Time][is.na(data.import[,myField])]
,sep=" ")
,format=myFormat,usetz=FALSE)
# B.5.2.2. Update Date if NA (use Date_Time)
myField   <- ContData.env$myName.Date
myFormat  <- ContData.env$myFormat.Date #"%Y-%m-%d"
#   data.import[,myField][data.import[,myField]==""] <- strftime(data.import[,myName.DateTime][data.import[,myName.Date]==""]
#                                                               ,format=myFormat,usetz=FALSE)
data.import[,myField][is.na(data.import[,myField])] <- strftime(data.import[,ContData.env$myName.DateTime][is.na(data.import[,myField])]
,format=myFormat,usetz=FALSE)
# B.5.2.3. Update Time if NA (use Date_Time)
myField   <- ContData.env$myName.Time
myFormat  <- ContData.env$myFormat.Time #"%H:%M:%S"
#   data.import[,myField][data.import[,myField]==""] <- strftime(data.import[,myName.DateTime][data.import[,myName.Time]==""]
#                                                               ,format=myFormat,usetz=FALSE)
data.import[,myField][is.na(data.import[,myField])] <- as.POSIXct(data.import[,ContData.env$myName.DateTime][is.na(data.import[,myField])]
,format=myFormat,usetz=FALSE)
#
# old code just for reference
# B.5.5. Force Date and Time format
#   data.import[,myName.Date] <- strftime(data.import[,myName.Date],format="%Y-%m-%d")
#   data.import[,myName.Time] <- as.POSIXct(data.import[,myName.Time],format="%H:%M:%S")
#   data.import[,myName.DateTime] <- strftime(data.import[,myName.DateTime],format="%Y-%m-%d %H:%M:%S")
#
#
# Create Month and Day Fields
# month
#     myField   <- "month"
#     data.import[,myField] <- data.import[,myName.Date]
#     myFormat  <- "%m"
#     data.import[,myField][!is.na(data.import[,myName.Date])] <- strftime(data.import[,myName.Date][!is.na(data.import[,myName.DateTime])]
#                                                                     ,format=myFormat,usetz=FALSE)
data.import[,ContData.env$myName.Mo] <- as.POSIXlt(data.import[,ContData.env$myName.Date])$mon+1
# day
#     myField   <- "day"
#     data.import[,myField] <- data.import[,myName.Date]
#     myFormat.In  <- myFormat.Date #"%Y-%m-%d"
#     myFormat.Out <- "%d"
#     data.import[,myField][!is.na(data.import[,myField])] <- format(strptime(data.import[,myField][!is.na(data.import[,myField])],format=myFormat.In)
#                                                                    ,format=myFormat.Out)
data.import[,ContData.env$myName.Day] <- as.POSIXlt(data.import[,ContData.env$myName.Date])$mday
# year
data.import[,ContData.env$myName.Yr] <- as.POSIXlt(data.import[,ContData.env$myName.Date])$year+1900
#
#     # example of classes for POSIXlt
#     Sys.time()
#     unclass(as.POSIXlt(Sys.time()))
#     ?DateTimeClasses
#
# B.6. QC for each Data Type present ####
# sub routine adds QC Calcs, QC Test Flags, Assigns overall Flag, and removes QC Calc Fields
# cycle each data type (manually code)
#
# skip if not present
# 20170512, move message inside of IF so user doesn't see it.
#
# 6.01. WaterTemp
myField <- ContData.env$myName.WaterTemp
myMsg.data <- "WaterTemp"
myMsg <- paste("WORKING (QC Tests and Flags - ",myMsg.data,")",sep="")
myItems.Complete <- myItems.Complete + 1
myItems.Log[intCounter,2] <- myMsg
fun.Msg.Status(myMsg, intCounter, intItems.Total, strFile)
flush.console()
fun.data.import <- data.import
myField <- ContData.env$myName.WaterTemp
fun.myField.Data <- myField
fun.myThresh.Gross.Fail.Hi <- ContData.env$myThresh.Gross.Fail.Hi.WaterTemp
fun.myThresh.Gross.Fail.Lo <- ContData.env$myThresh.Gross.Fail.Lo.WaterTemp
fun.myThresh.Gross.Suspect.Hi <- ContData.env$myThresh.Gross.Suspect.Hi.WaterTemp
fun.myThresh.Gross.Suspect.Lo <- ContData.env$myThresh.Gross.Suspect.Lo.WaterTemp
fun.myThresh.Spike.Hi <- ContData.env$myThresh.Spike.Hi.WaterTemp
fun.myThresh.Spike.Lo <- ContData.env$myThresh.Spike.Lo.WaterTemp
fun.myThresh.RoC.SD.period <- ContData.env$myThresh.RoC.SD.period.WaterTemp
fun.myThresh.RoC.SD.number <- ContData.env$myThresh.RoC.SD.number.WaterTemp
fun.myThresh.Flat.Hi <- ContData.env$myThresh.Flat.Hi.WaterTemp
fun.myThresh.Flat.Lo <- ContData.env$myThresh.Flat.Lo.WaterTemp
fun.myThresh.Flat.Tolerance <- ContData.env$myThresh.Flat.Tolerance.WaterTemp
# Jump to line 920
fun.myField.Data.ALL <- names(fun.data.import)[names(fun.data.import) %in% ContData.env$myNames.DataFields]
boo.Offset <- fun.OffsetCollectionCheck(fun.data.import, fun.myField.Data.ALL, ContData.env$myName.DateTime)
if(boo.Offset==TRUE) {##IF.boo.Offset.START
# check time interval (na.omit removes all)
df.check <- na.omit(fun.data.import[,c(ContData.env$myName.DateTime,fun.myField.Data)])
# convert from Character to time if necessary (not necessary)
# if (is.character(df.check[,ContData.env$myName.DateTime])==TRUE){
#   myFormat  <- ContData.env$myFormat.DateTime #"%Y-%m-%d %H:%M:%S"
#   # df.check[,ContData.env$myName.DateTime] <- strftime(df.check[,ContData.env$myName.DateTime],
#   #                                                     format=myFormat,
#   #                                                     tz=ContData.env$myTZ)
# }
x <- df.check[,ContData.env$myName.DateTime]
myTimeDiff.all <- difftime(x[-1],x[-length(x)])
myTimeDiff <- median(as.vector(myTimeDiff.all))
# create time series
myTS <- seq(as.POSIXlt(min(x),tz=ContData.env$myTZ),as.POSIXlt(max(x),tz=ContData.env$myTZ),by="30 min") #by=paste0(myTimeDiff," min"))
length(myTS)
#~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
# remove other data fields (and extra times) before proceeding
### Fields to keep
myFlds.Keep <- c(ContData.env$myName.SiteID,
ContData.env$myName.DateTime, ContData.env$myName.Date, ContData.env$myName.Time,
ContData.env$myName.Mo, ContData.env$myName.Day, ContData.env$myName.Yr,
fun.myField.Data, paste0(ContData.env$myName.Flag,".",fun.myField.Data))
### Modify the DF
# keep only the relevant data field and remove all NA (case-wise)
fun.data.import.mod <- na.omit(fun.data.import[,myFlds.Keep])
#~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
# Check length.  If different add in extra times
## NA records would have been removed earlier
if (length(myTS) != nrow(df.check)){##IF.length.START
# add extra rows to new Time Series
ts.alltimes <- as.data.frame(as.character(myTS))
names(ts.alltimes) <- ContData.env$myName.DateTime
# merge (works with datetime as character but not as a POSIX field)
#df.check[,ContData.env$myName.DateTime] <- as.POSIXlt(df.check[,ContData.env$myName.DateTime],origin = "1900-01-01",tz=ContData.env$myTZ)
ts.alltimes.data <- merge(ts.alltimes, fun.data.import.mod, by=ContData.env$myName.DateTime)
# use new df moving forward
fun.data.import.mod <- ts.alltimes.data
}##IF.length.END
# then merge back at end
} else {
# rename fun.data.import (for non Offset)
fun.data.import.mod <- fun.data.import
}##IF.boo.Offset.END
# A.1. Calc, SD Time Interval
myCalc <- "SD.Time"
myField <- paste(fun.myField.Data,myCalc,sep=".")
# calculate as separate variable
#http://stackoverflow.com/questions/8857287/how-to-add-subtract-time-from-a-posixlt-time-while-keeping-its-class-in-r
# myT will be a POSIXt object
myT <- strptime(fun.data.import.mod[,ContData.env$myName.DateTime],format=ContData.env$myFormat.DateTime)
myT$hour <- myT$hour - fun.myThresh.RoC.SD.period
# add back to dataframe
fun.data.import.mod[,myField] <- as.character(myT)
#
# alternate calculation, not used
#seq.POSIXt( from=Sys.time(), by="-25 hour", length.out=2 )[2]
#
# variable for following block
myField.T1 <- myField
#
# A.2. Calc, SD, calc SD of last 25 hours
myCalc <- "SD"
myField <- paste(fun.myField.Data,myCalc,sep=".")
#myField.T2 <- myName.DateTime
#   ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
#   # calc SD
#   #
#   #a <- fun.data.import.mod[,myName.WaterTemp]
#   #b <- fun.data.import.mod[,myName.DateTime]
#   #sd(a[b<="2014-04-22 10:00:00" & b>="2014-01-13 11:00:00"],na.rm=TRUE)
#   #sd(a,na.rm=TRUE)
#   #
#   fun.data.import.mod[,myField] <- sd(fun.data.import.mod[,fun.myField.Data][fun.data.import.mod[,myName.DateTime]<="2014-04-22 10:00:00" & fun.data.import.mod[,myName.DateTime]>="2014-01-13 11:00:00"],na.rm=TRUE)
# ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
## zoo version with rollapply
# need at least 5 records
if(nrow(fun.data.import.mod)<5) {##IF.nrow.START
myMsg <- paste("\n
The data file has less than 5 records.
The scripts will not work properly until you have more data."
,sep="")
stop(myMsg)
}##IF.1.END
# get interval distance (will crash if less than 5 records)
# myT.diff <- difftime(fun.data.import.mod[5,ContData.env$myName.DateTime],fun.data.import.mod[4,ContData.env$myName.DateTime],units="mins")
# myT.diff[[1]]
# use median of all (no lower limit)
x <- fun.data.import.mod[,ContData.env$myName.DateTime]
myT.diff.all <- difftime(x[-1],x[-length(x)], units="mins")
myT.diff <- median(as.vector(myTimeDiff.all))
# convert DateTime to POSIX object (already done above)
#myT <- strptime(fun.data.import.mod[,myName.DateTime],format=myFormat.DateTime)
# A.2. Use data "as is"
# create zoo object of data and date/time (use row num instead)
zoo.data <- zoo::zoo(fun.data.import.mod[,fun.myField.Data],seq(from=1,to=nrow(fun.data.import.mod),by=1))  # works
#
# B. Rolling SD
# time difference is in minutes and Threshold is in hours
# "By" in rollapply goes by # of records not by a set time.
RollBy <- fun.myThresh.RoC.SD.period/(myT.diff[[1]]/60)
# right align says the previous 50
# +1 is to include the record itself
#RollSD <- rollapply(data=zoo.merge,width=RollBy+1,FUN=sd,na.rm=TRUE,fill=NA,align="right")
RollSD <- zoo::rollapply(data=zoo.data,width=RollBy+1,FUN=sd,na.rm=TRUE,fill=NA,align="right")
# add to data frame
fun.data.import.mod[,myField] <- RollSD
# clean up
rm(myT)
rm(zoo.data)
rm(RollSD)
#
# ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
#   #~~~~~~~~~~~~~
#   # slow but works (~10 seconds for 5k records)
#   # *******need to change to sapply***********
#   for (m in 1:nrow(fun.data.import.mod)) {
# #     print(m)
# #     flush.console()
#     fun.data.import.mod[m,myField] <- sd(fun.data.import.mod[,fun.myField.Data][
#         fun.data.import.mod[,myName.DateTime]<=fun.data.import.mod[m,myName.DateTime]
#         & fun.data.import.mod[,myName.DateTime]>=fun.data.import.mod[m,myField.T1]
#         ],na.rm=TRUE)
#   }
#   #
# A.3. Calc, NxSD, SD * n.per
myCalc.1 <- "SD"
myCalc.2 <- "SDxN"
myField.1 <- paste(fun.myField.Data,myCalc.1,sep=".")
myField.2 <- paste(fun.myField.Data,myCalc.2,sep=".")
fun.data.import.mod[,myField.2] <- fun.data.import.mod[,myField.1] * fun.myThresh.RoC.SD.number
#
# A.4. Calc, Diff (1:5) (5 is default but can be more)
for (i in 1:ContData.env$myThresh.Flat.MaxComp) {##FOR.i.START
myCalc <- paste("n",i,sep=".")
myField <- paste(fun.myField.Data,myCalc,sep=".")
fun.data.import.mod[-(1:i),myField] <- diff(as.numeric(fun.data.import.mod[,fun.myField.Data]),lag=i)
#
}##FOR.i.END
# only works as for loop, won't work as vector
#
#http://stackoverflow.com/questions/18862114/r-count-number-of-columns-by-a-condition-for-each-row
#
# A.5. Calc, flat.Hi, count n.1 etc if less than toler
myCalc <- "flat.Hi"
myField <- paste(fun.myField.Data,myCalc,sep=".")
myThresh <- fun.myThresh.Flat.Hi
# Fields to check
myFields.Match <- match(paste(fun.myField.Data,"n",1:myThresh,sep="."), names(fun.data.import.mod))
# use rowSums to count the fields
fun.data.import.mod[,myField] <- rowSums(abs(fun.data.import.mod[,myFields.Match])<=fun.myThresh.Flat.Tolerance)
#
# A.6. Calc, flat.Lo, count if less than toler
myCalc <- "flat.Lo"
myField <- paste(fun.myField.Data,myCalc,sep=".")
myThresh <- fun.myThresh.Flat.Lo
# Fields to check
myFields.Match <- match(paste(fun.myField.Data,"n",1:myThresh,sep="."), names(fun.data.import.mod))
# use rowSums to count the fields
fun.data.import.mod[,myField] <- rowSums(abs(fun.data.import.mod[,myFields.Match])<=fun.myThresh.Flat.Tolerance)
#
## B. Generate Flags based on Calculation Fields ####
# B.1. Gross
myQCTest <- "Gross"
myField <- paste("Flag",myQCTest,fun.myField.Data,sep=".")
# Assign Flags
# default value
fun.data.import.mod[,myField] <- ContData.env$myFlagVal.NotEval
# data is NA then flag = 9 (missing data)
fun.data.import.mod[,myField][is.na(fun.data.import.mod[,fun.myField.Data])==TRUE] <- ContData.env$myFlagVal.NoData
# different test for water level, only if negative
if(fun.myField.Data==ContData.env$myName.SensorDepth) {##IF.Gross.SensorDepth.START
# data < 0 (i.e., negative) = 4 (fail)
fun.data.import.mod[,myField][fun.data.import.mod[,fun.myField.Data] < 0] <- ContData.env$myFlagVal.Fail
# otherwise flag = 1 (pass)
fun.data.import.mod[,myField][fun.data.import.mod[,myField]==ContData.env$myFlagVal.NotEval] <- ContData.env$myFlagVal.Pass
# different test for discharge
} else if(fun.myField.Data==ContData.env$myName.Discharge) {
# data < 0 (i.e., negative) = 4 (fail)
fun.data.import.mod[,myField][fun.data.import.mod[,fun.myField.Data] < 0] <- ContData.env$myFlagVal.Fail
# otherwise flag = 1 (pass)
fun.data.import.mod[,myField][fun.data.import.mod[,myField]==ContData.env$myFlagVal.NotEval] <- ContData.env$myFlagVal.Pass
} else {
# data >= Suspect.Hi then flag = 3 (suspect)
fun.data.import.mod[,myField][fun.data.import.mod[,fun.myField.Data] >= fun.myThresh.Gross.Suspect.Hi] <- ContData.env$myFlagVal.Suspect
# data <= Suspect.Lo then flag = 3 (Suspect)
fun.data.import.mod[,myField][fun.data.import.mod[,fun.myField.Data] <= fun.myThresh.Gross.Suspect.Lo] <- ContData.env$myFlagVal.Suspect
# data >= Fail.Hi then flag = 4 (fail)
fun.data.import.mod[,myField][fun.data.import.mod[,fun.myField.Data] >= fun.myThresh.Gross.Fail.Hi] <- ContData.env$myFlagVal.Fail
# data <= Fail.Lo then flag = 4 (fail)
fun.data.import.mod[,myField][fun.data.import.mod[,fun.myField.Data] <= fun.myThresh.Gross.Fail.Lo] <- ContData.env$myFlagVal.Fail
# otherwise flag = 1 (pass)
fun.data.import.mod[,myField][fun.data.import.mod[,myField]==ContData.env$myFlagVal.NotEval] <- ContData.env$myFlagVal.Pass
}##IF.Gross.SensorDepth.END
# QC
#table(fun.data.import.mod[,myField])
#
# B.2. Spike
myQCTest <- "Spike"
myField <- paste("Flag",myQCTest,fun.myField.Data,sep=".")
myField.Calc.1 <- paste(fun.myField.Data,"n",1,sep=".")
# Assign Flags
# default value
fun.data.import.mod[,myField] <- ContData.env$myFlagVal.NotEval
# diff 1 is NA then flag = 9 (missing data)
fun.data.import.mod[,myField][is.na(fun.data.import.mod[,myField.Calc.1])==TRUE] <- ContData.env$myFlagVal.NoData
# abs(diff 1) >= spike Lo then flag = 3 (suspect)
fun.data.import.mod[,myField][abs(fun.data.import.mod[,myField.Calc.1]) >= fun.myThresh.Spike.Lo] <- ContData.env$myFlagVal.Suspect
# abs(diff 1) >= spike Hi then flag = 4 (fail)
fun.data.import.mod[,myField][abs(fun.data.import.mod[,myField.Calc.1]) >= fun.myThresh.Spike.Hi] <- ContData.env$myFlagVal.Fail
# otherwise flag = 1 (pass)
fun.data.import.mod[,myField][fun.data.import.mod[,myField]==ContData.env$myFlagVal.NotEval] <- ContData.env$myFlagVal.Pass
# QC
#table(fun.data.import.mod[,myField])
#
# B.3. RoC
myQCTest <- "RoC"
myField <- paste("Flag",myQCTest,fun.myField.Data,sep=".")
myField.Calc.1 <- paste(fun.myField.Data,"n",1,sep=".")
myField.Calc.2 <- paste(fun.myField.Data,"SDxN",sep=".")
# Assign Flags
# default value
fun.data.import.mod[,myField] <- ContData.env$myFlagVal.NotEval
# data is NA then flag = 9 (missing data)
fun.data.import.mod[,myField][is.na(fun.data.import.mod[,fun.myField.Data])==TRUE] <- ContData.env$myFlagVal.NoData
# sd is NA then flag = 9 (missing data)
fun.data.import.mod[,myField][is.na(fun.data.import.mod[,myField.Calc.1])==TRUE] <- ContData.env$myFlagVal.NoData
# diff 1 > SD*N then flag = 3 (suspect)
fun.data.import.mod[,myField][abs(fun.data.import.mod[,myField.Calc.1]) > fun.data.import.mod[,myField.Calc.2]] <- ContData.env$myFlagVal.Suspect
# otherwise flag = 1 (pass) [no 4/Fail]
fun.data.import.mod[,myField][fun.data.import.mod[,myField]==ContData.env$myFlagVal.NotEval] <- ContData.env$myFlagVal.Pass
# QC
#table(fun.data.import.mod[,myField])
#
# B.4. Flat
myQCTest <- "Flat"
myField <- paste("Flag",myQCTest,fun.myField.Data,sep=".")
myField.Calc.1 <- paste(fun.myField.Data,"flat.Hi",sep=".")
myField.Calc.2 <- paste(fun.myField.Data,"flat.Lo",sep=".")
# default value
fun.data.import.mod[,myField] <- ContData.env$myFlagVal.NotEval
# Lo >= Thresh.Lo = 3 (suspect)
fun.data.import.mod[,myField][fun.data.import.mod[,myField.Calc.2] >= fun.myThresh.Flat.Lo] <- ContData.env$myFlagVal.Suspect
# Hi >= Thresh.Hi = 4 (fail)
fun.data.import.mod[,myField][fun.data.import.mod[,myField.Calc.1] >= fun.myThresh.Flat.Hi] <- ContData.env$myFlagVal.Fail
# otherwise flag = 1 (pass)
fun.data.import.mod[,myField][fun.data.import.mod[,myField]==ContData.env$myFlagVal.NotEval] <- ContData.env$myFlagVal.Pass
# QC
#table(fun.data.import.mod[,myField])
#
#
# C. Assign Overall Data Flag ####
myField <- paste(ContData.env$myName.Flag,fun.myField.Data,sep=".")
#myNames.QCTests
# get column numbers (match) for QCTest Flags for this data
myFields.Match <- match(paste("Flag",ContData.env$myNames.QCTests,fun.myField.Data,sep="."), names(fun.data.import.mod))
# Conditional rowSums for number of flag fields with specified flags
myFlags.Num.Pass    <- rowSums(fun.data.import.mod[,myFields.Match]==ContData.env$myFlagVal.Pass)
myFlags.Num.Suspect <- rowSums(fun.data.import.mod[,myFields.Match]==ContData.env$myFlagVal.Suspect )
myFlags.Num.Fail    <- rowSums(fun.data.import.mod[,myFields.Match]==ContData.env$myFlagVal.Fail)
myFlags.Num.Missing <- rowSums(fun.data.import.mod[,myFields.Match]==ContData.env$myFlagVal.NoData)
myFlags.Num.OK      <- rowSums(fun.data.import.mod[,myFields.Match]==ContData.env$myFlagVal.Pass | fun.data.import.mod[,myFields.Match]==ContData.env$myFlagVal.NoData)
# Assign
# default value
fun.data.import.mod[,myField] <- ContData.env$myFlagVal.NotEval
# any QC Test flags = 3 then flag = 3 (suspect)
fun.data.import.mod[,myField][myFlags.Num.Suspect > 0] <- ContData.env$myFlagVal.Suspect
# any QC Test flags = 4 then flag = 4 (fail)
fun.data.import.mod[,myField][myFlags.Num.Fail > 0] <- ContData.env$myFlagVal.Fail
# all QC Test flags = 1 then flag = 1 (pass)
fun.data.import.mod[,myField][myFlags.Num.Pass == length(ContData.env$myNames.QCTests)] <- ContData.env$myFlagVal.Pass
# all QC Test flags = 1 or 9 then flag = 1 (pass)
fun.data.import.mod[,myField][myFlags.Num.OK == length(ContData.env$myNames.QCTests)] <- ContData.env$myFlagVal.Pass
#fun.data.import.mod[,myField][fun.data.import.mod[,myField]==myFlagVal.NotEval] <- myFlagVal.Pass
# data is NA then flag = 9 (missing data)
fun.data.import.mod[,myField][is.na(fun.data.import.mod[,fun.myField.Data])==TRUE] <- ContData.env$myFlagVal.NoData
# QC
#table(fun.data.import.mod[,myField])
FlagFields.Keep <- c(myField, paste(ContData.env$myName.Flag,ContData.env$myNames.QCTests,fun.myField.Data,sep="."))
names(data.import.mod)
names(fun.data.import.mod)
names(fun.data.import)
ContData.env$myNames.QCTests
ContData.env$myNames.QCCalcs
fun.data.import.mod <- fun.data.import.mod[,-(ContData.env$myNames.QCCalcs)]
fun.data.import.mod <- fun.data.import.mod[,-na.omit(ContData.env$myNames.QCCalcs)]
fun.data.import.mod <- fun.data.import.mod[,-paste(fun.myField.Data,ContData.env$myNames.QCCalcs,sep=".")]
paste(fun.myField.Data,ContData.env$myNames.QCCalcs,sep="."
)
fun.data.import.mod <- fun.data.import.mod[,-na.omit(paste(fun.myField.Data,ContData.env$myNames.QCCalcs,sep="."))]
myFields.Drop <- match(paste(fun.myField.Data,ContData.env$myNames.QCCalcs,sep="."), names(fun.data.import.mod))
fun.data.import.mod <- fun.data.import.mod[,-na.omit(myFields.Drop)]
names(fun.data.import.mod)
FlagFields.Keep
Fld.New <- names(fun.data.import.mod)[names(fun.data.import.mod) %in% names(fun.data.import)==FALSE]
boo.Offset
Fld.New <- names(fun.data.import.mod)[names(fun.data.import.mod) %in% names(fun.data.import)==FALSE]
Fld.New
myField
Fld.Flag.Param <- match(myField, names(fun.data.import))
Fld.Flag.Param
names(fun.data.import)
names(fun.data.import)[-12]
Fld.Flag.Param <- match(myField, names(fun.data.import))
Fld.New <- names(fun.data.import.mod)[names(fun.data.import.mod) %in% names(fun.data.import)[-Fld.Flag.Param]==FALSE]
DF.Return <- merge(fun.data.import[,-Fld.Flag.Param], fun.data.import.mod[,c(ContData.env$myName.DateTime, Fld.New)],
by=ContData.env$myName.DateTime, all.x=TRUE)
names(DF.Return)
View(DF.Return)
myLibrary <- "ContDataQC" # "ContDataQC","MMIcalc","MMIcalcNV","MBSStools","XC95"
library(devtools)
setwd(paste0("./",myLibrary))
devtools::document()
setwd("..") # return to root directory first
devtools::install(myLibrary)
library(myLibrary,character.only = TRUE)
setwd(paste0("./",myLibrary))
getwd()
library(ContDataQC)
Selection.Operation <- c("GetGageData","QCRaw", "Aggregate", "SummaryStats")
Selection.Type      <- c("Air","Water","AW","Gage","AWG","AG","WG")
Selection.SUB <- c("Data1_RAW","Data2_QC","Data3_Aggregated","Data4_Stats")
myDir.SUB.import <- ""
myDir.SUB.export <- ""
myData.Type      <- Selection.Type[3] #"AW"
myDir.SUB.import <- Selection.SUB[1] #"Data1_RAW"
myDir.SUB.export <- Selection.SUB[2] #"Data2_QC"
myData.Operation <- "QCRaw" #Selection.Operation[2]
myData.SiteID    <- "test4"
myData.DateRange.Start  <- "2016-04-18"
myData.DateRange.End <- "2016-07-26"
ContDataQC(myData.Operation, myData.SiteID, myData.Type, myData.DateRange.Start, myData.DateRange.End, getwd(), "", "")
