# 5.1. Cycle each present field
for (j in myNames.DataFields2Mod) {##FOR.j.START
#
# A. Add comment field and leave blank
data.import[,paste(myName.Comment.Mod,j,sep=".")] <- ""
# B. Add data.RAW and populate with original data
data.import[,paste(myName.Raw,j,sep=".")] <- data.import[,j]
#
}##FOR.j.END
#
#     # leave as a loop so get RAW and Comment together
#     j <- myNames.DataFields2Mod
#     # A. Add comment field and leave blank
#     data.import[,paste(myName.Comment.Mod,j,sep=".")] <- ""
#     # B. Add data.RAW and populate with original data
#     data.import[,paste(myName.Raw,j,sep=".")] <- data.import[,j]
#
# 6-9 #not here
#
#~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
# save file then run QC Report in a separate Script
#~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
wd <- "C:/Users/Erik.Leppo/OneDrive - Tetra Tech, Inc/MyDocs_OneDrive/GitHub/ContDataQC"
setwd(wd)
if(boo_DEBUG==TRUE){
myConfig <- file.path(system.file(package="ContDataQC"), "extdata", "config.ORIG.R")
source(myConfig)
}
# DATA FILE INFORMATION
# Report Info
myReportDate <- format(Sys.Date(),ContData.env$myFormat.Date)
cat(paste("**Report Date:** ",myReportDate,"\n\n",sep=""))
myUser <- Sys.getenv("USERNAME")
cat(paste("**Generated By:** ",myUser,"\n\n",sep=""))
#filename
cat("**Filename:** ",strFile,"\n\n",sep="")
mySiteID <- data.import[1,ContData.env$myName.SiteID]
cat(paste("**SiteID:** ",mySiteID,"\n\n",sep=""))
if(exists("fun.myData.DateRange.Start")==TRUE){
POR.Requested <- paste(fun.myData.DateRange.Start," to ",fun.myData.DateRange.End, sep="")
} else {
POR.Requested <- "NA"
}
cat(paste("**Period of Record, Requested:** ",POR.Requested,sep="",collapse="\n\n"))
myNumRecords <- nrow(data.import) # 20170228, mod from records 10 and 11 to half way point
# myTimeDiff <- difftime(data.import[10,ContData.env$myName.DateTime],data.import[11,ContData.env$myName.DateTime],units="mins")
#x <- data.import[,ContData.env$myName.DateTime]
myT <- strptime(data.import[,ContData.env$myName.DateTime],format=ContData.env$myFormat.DateTime)
myTimeDiff.all <- difftime(myT[-1],myT[-length(myT)],units="mins")
myTimeDiff <- median(as.vector(myTimeDiff.all),na.rm=TRUE)
cat(paste("\n\n**Period of Record, Actual:** ",min(data.import[,ContData.env$myName.Date])," to ",max(data.import[,ContData.env$myName.Date]),"\n\n",sep=""))
cat(paste("**Recording Interval:** ",myTimeDiff[1]," minutes\n\n",sep=""))
if(exists("strFile.DataType")==TRUE){
myDataType <- strFile.DataType
} else {
myDataType <- "NA"
}
cat(paste("**Data Type:** ",myDataType,"\n\n",sep=""))  # need to do better
myParameters.ALL     <- ContData.env$myNames.DataFields[ContData.env$myNames.DataFields
%in% names(data.import)==TRUE]
myParameters.Lab.ALL <- ContData.env$myNames.DataFields.Lab[ContData.env$myNames.DataFields
%in% names(data.import)==TRUE]
# Filter out Discrete
myParameters     <- myParameters.ALL[!grepl(ContData.env$myPrefix.Discrete,myParameters.ALL)]
myParameters.Lab <- myParameters.Lab.ALL[!grepl(ContData.env$myPrefix.Discrete,myParameters.Lab.ALL)]
#cat("**Parameters:** ",paste(myParameters.Lab,", ",sep=""),"\n\n",sep="")
# above line not working, preventing pandoc conversion to WORD
#cat("**Included Parameters:** \n\n")
cat("**Parameters Included:** ",paste(myParameters.ALL,", ",sep=""),"\n\n",sep="")
#~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
#     2.1. Records by Month/Day
#     split so easier to put on paper
#     number of records by month/day (split 1:15 and 16:31)
#
# format = markdown/pandoc = seems to be the same.  All rows but no columns in Word.
# Have to use on table not ftable.  ftable better by itself but doesn't work with knitr::kable.
# # QC, if days less than count = 15
#*Error in table.  Only printing half.* (fixed for sites with <15 days)
# if((max(data.import[,"day"])-min(data.import[,"day"]))<15) {##IF.daycount.START
#   myTable <- table(data.import[,"month"],data.import[,"day"])
#   print(knitr::kable(myTable, format="markdown",row.names=TRUE))
# } else {
#   #
#   #myTable.month.day.rec.LTE15 <-
#   myTable <- table(data.import[,"month"][data.import[,"day"]<=15],data.import[,"day"][data.import[,"day"]<=15])
#     print(knitr::kable(myTable, format="markdown", row.names=TRUE))
#     #knitr::kable(myTable.month.day.rec.LTE15, format="pandoc", caption = "Title of the table")
#   cat("\n\n")
#   #
#   # myTable.month.day.rec.GT15 <-
#   myTable <- table(data.import[,"month"][data.import[,"day"]>15],data.import[,"day"][data.import[,"day"]>15])
#     print(knitr::kable(myTable, format="markdown", row.names=TRUE))
#
# }##IF.daycount.END
# Convert time interval (minutes) to number per day
records.expected <- round(24*60/as.numeric(myTimeDiff[1]),1)
cat(paste("Estimated number of records per day is ",records.expected,".",sep=""))
cat("\n\n")
cat("Number of records by year and month (with totals).")
cat("\n")
myTable <- addmargins(table(data.import[,ContData.env$myName.Yr],data.import[,ContData.env$myName.Mo]))
print(knitr::kable(myTable, format="markdown", row.names=TRUE))
cat("\n\n")
# revert to longer table (20170228)
cat("Number of records by day and month (with totals).")
cat("\n")
myTable <- addmargins(table(data.import[,ContData.env$myName.Day],data.import[,ContData.env$myName.Mo]))
print(knitr::kable(myTable, format="markdown", row.names=TRUE))
cat("\n\n")
#
#     pandoc.table(myTable.month.day.rec.GT15,style="rmarkdown")
#
#
myTable.month.day.rec <- table(data.import[,ContData.env$myName.Mo],data.import[,ContData.env$myName.Day])
#     use apply function to count number of records not equal to the expected value
cat("\n\n")
#
myTable.DateTime.N <- aggregate(data.import[,ContData.env$myName.SiteID]
~ data.import[,ContData.env$myName.DateTime]
, data=data.import,FUN=length)
# myTable <- myTable.DateTime.N[myTable.DateTime.N[,ContData.env$myName.SiteID]!=1,]
# cat(paste0("Date and time records with more than one entry; N=",nrow(myTable),". Duplicate date.time records are shown below."))
# cat("\n")
#   print(knitr::kable(myTable, format="markdown", row.names=TRUE))
# mask error, 20170307
# Missing Dates
myDateRange.Data <- seq(as.Date(min(data.import[,ContData.env$myName.Date]))
,as.Date(max(data.import[,ContData.env$myName.Date]))
,by="day")
if(exists("fun.myData.DateRange.Start")==TRUE){
myDateRange.Target <- seq(as.Date(fun.myData.DateRange.Start)
,as.Date(fun.myData.DateRange.End)
,by="day")
} else {
myDateRange.Target <- myDateRange.Data
}
myDateRange.Target.Missing <- myDateRange.Target[!myDateRange.Target %in% myDateRange.Data]
cat(paste0("Below are the dates with missing data between the min (",min(myDateRange.Data)
,") and max(",max(myDateRange.Data)," for the provided data. There are "
,length(myDateRange.Target.Missing)," records."))
cat("\n\n")
print(ifelse(length(myDateRange.Target.Missing)==0,"",myDateRange.Target.Missing))
#~~~~~~~~~~~~~~~~~~~~~~
cat("\n\n")
print("Parameters:")
cat("\n\n")
print(myParameters)
i <- myParameters[1]
i.num <- match(i,myParameters)
myTitle.Sub <- myParameters.Lab[i.num]
cat("## QC TESTS, ",i,"\n\n",sep="")
#cat(paste("**QC TESTS,",myTitle.Sub,sep=""))
# 3.1. Flags, overall
cat(myTitle.Sub <- "### Flags")
cat("\n\n")
cat("#### Flag summary, overall number of records.")
cat("\n\n")
myTable <- addmargins(table(data.import[,paste("Flag",i,sep=".")]),1)
print(knitr::kable(t(as.matrix(myTable)), format = "markdown"))
cat("\n\n")
#
# 3.1. Number of Records (revised 20170228)
# Convert time interval (minutes) to number per day
records.expected <- round(24*60/as.numeric(myTimeDiff[1]),1)
cat(paste("Estimated number of records per day is ",records.expected,".",sep=""))
cat("\n\n")
#
cat("Number of records by year and month (with totals)")
cat("\n")
myTable <- addmargins(table(data.import[,ContData.env$myName.Yr],data.import[,ContData.env$myName.Mo]))
print(knitr::kable(myTable, format="markdown", row.names=TRUE))
cat("\n\n")
#
cat("Number of records by day and month (with totals)")
cat("\n")
myTable <- addmargins(table(data.import[,ContData.env$myName.Day],data.import[,ContData.env$myName.Mo]))
print(knitr::kable(myTable, format="markdown", row.names=TRUE))
cat("\n\n")
#
# identify days/months where not the expected number of records
# (expect first and last day)
#    print("days where not the expected number of records")
#
# 3.2. Flags by QC Test
cat("\n\n")
cat("#### Flags by QC Test")
cat("\n\n")
cat("##### Flags, Gross\n\n")
myTable <- addmargins(table(data.import[,paste(ContData.env$myName.Flag,"Gross",i,sep=".")]),1)
print(knitr::kable(t(as.matrix(myTable)), format = "markdown"))
cat("\n\n")
cat("##### Flags, Spike\n\n")
myTable <- addmargins(table(data.import[,paste(ContData.env$myName.Flag,"Spike",i,sep=".")]),1)
print(knitr::kable(t(as.matrix(myTable)), format = "markdown"))
cat("\n\n")
cat("##### Flags, RoC\n\n")
myTable <- addmargins(table(data.import[,paste(ContData.env$myName.Flag,"RoC",i,sep=".")]),1)
print(knitr::kable(t(as.matrix(myTable)), format = "markdown"))
cat("\n\n")
cat("##### Flags, Flat\n\n")
myTable <- addmargins(table(data.import[,paste(ContData.env$myName.Flag,"Flat",i,sep=".")]),1)
print(knitr::kable(t(as.matrix(myTable)), format = "markdown"))
cat("\n\n")
cat("QC Test Flag fields are saved in the data file so the user can identify data points that have been flagged as suspect or fail.")
#
#myFlagTests <- c("Gross","Spike","RoC","Flat")
#(myTable.Flags.Flat <- ftable(data.import[,paste("Flag",myFlagTests,i,sep=".")]))
#
cat(paste("\n\n Test results marked as ",ContData.env$myFlagVal.NoData," (No/Missing Data) if unable to calculate the end point needed for the test.  For example, the first record does not have a previous record for comparison for the Gross QC Test.  QC Test flags are saved in the data file.",sep=""))
#
# 3.3. Plot
data.plot <- data.import
#
plot_format <- "ggplot" # "base"
data.plot[, ContData.env$myName.DateTime] <- as.POSIXct(data.plot[, ContData.env$myName.DateTime])
# ggplot, main
scale_lab   <- c("Continuous", "Discrete")
scale_col   <- c("dark gray", "black")
scale_shape <- c(21, 24)
scale_fill  <- scale_col
p_i <- ggplot2::ggplot(data=data.plot, ggplot2::aes_string(x=ContData.env$myName.DateTime, y=i)) +
ggplot2::geom_point(ggplot2::aes(color="continuous"
, shape="continuous"
, fill="continuous"), na.rm=TRUE) +
ggplot2::scale_x_datetime(date_labels = "%Y-%m-%d") +
ggplot2::labs(title=mySiteID, x=ContData.env$myLab.Date, y=myParameters.Lab[i.num]) +
ggplot2::theme(plot.title=ggplot2::element_text(hjust=0.5)
, plot.subtitle=ggplot2::element_text(hjust=0.5))
myDiscrete <- paste(ContData.env$myPrefix.Discrete,i,sep=".")
myDiscrete
myDiscrete %in% myParameters.ALL == TRUE
data.plot[, ContData.env$myName.DateTime] <- as.POSIXct(data.plot[, ContData.env$myName.DateTime])
# ggplot, main
scale_lab   <- c("Continuous", "Discrete")
scale_col   <- c("dark gray", "black")
scale_shape <- c(21, 24)
scale_fill  <- scale_col
p_i <- ggplot2::ggplot(data=data.plot, ggplot2::aes_string(x=ContData.env$myName.DateTime, y=i)) +
ggplot2::geom_point(ggplot2::aes(color="continuous"
, shape="continuous"
, fill="continuous"), na.rm=TRUE) +
ggplot2::scale_x_datetime(date_labels = "%Y-%m-%d") +
ggplot2::labs(title=mySiteID, x=ContData.env$myLab.Date, y=myParameters.Lab[i.num]) +
ggplot2::theme(plot.title=ggplot2::element_text(hjust=0.5)
, plot.subtitle=ggplot2::element_text(hjust=0.5))
# ggplot, discrete points
# Add discrete (only if present)
myDiscrete <- paste(ContData.env$myPrefix.Discrete,i,sep=".")
if (myDiscrete %in% myParameters.ALL == TRUE){##IF.Discrete.START
p_i <- p_i + ggplot2::geom_point(data=data.plot
, ggplot2::aes_q(x=as.name(ContData.env$myName.DateTime)
, y=as.name(myDiscrete)
, color="discrete"
, shape="discrete"
, fill="discrete"), na.rm=TRUE)
} else {
p_i <- p_i + ggplot2::geom_blank(ggplot2::aes(color="discrete"
, shape="discrete"
, fill="discrete"))
}##IF.Discrete.END
# ggplot, Legend
p_i <- p_i +
ggplot2::scale_color_manual(name="Data", labels=scale_lab, values=scale_col) +
ggplot2::scale_shape_manual(name="Data", labels=scale_lab, values=scale_shape) +
ggplot2::scale_fill_manual(name="Data", labels=scale_lab, values=scale_fill)
# ggplot, show
print(p_i)
cat("\n\n")
data.plot <- data.import
plot_format <- "ggplot" # "base" or "ggplot"
data.plot[, ContData.env$myName.DateTime] <- as.POSIXct(data.plot[, ContData.env$myName.DateTime])
ContData.env$myName.AirTemp %in% myParameters & ContData.env$myName.WaterTemp %in% myParameters
cat("## PLOT, Temperature (Air vs. Water) \n\n" )
#
# ggplot, main
scale_lab   <- c("Air", "Water")
scale_col   <- c("green", "blue")
scale_fill  <- scale_col
scale_shape <- c(21, 21)
p2_t_aw <- ggplot2::ggplot(data=data.plot, ggplot2::aes(color="a"
, fill="b"
, shape="c")) +
ggplot2::geom_path(ggplot2::aes_q(x=as.name(ContData.env$myName.DateTime)
, y=as.name(ContData.env$myName.AirTemp)
, color="air"), na.rm=TRUE) +
ggplot2::geom_path(ggplot2::aes_q(x=as.name(ContData.env$myName.DateTime)
,y=as.name(ContData.env$myName.WaterTemp)
, color="water", na.rm=TRUE) +
ggplot2::scale_x_datetime(date_labels = "%Y-%m-%d") +
ggplot2::labs(title=mySiteID
, x=ContData.env$myLab.Date
, y=ContData.env$myLab.Temp.BOTH) +
ggplot2::theme(plot.title=ggplot2::element_text(hjust=0.5)
, plot.subtitle=ggplot2::element_text(hjust=0.5))
# ggplot, discrete points
myDiscrete <- paste(ContData.env$myPrefix.Discrete,i,sep=".")
p2_t_aw <- ggplot2::ggplot(data=data.plot, ggplot2::aes(color="a"
, fill="b"
, shape="c")) +
ggplot2::geom_path(ggplot2::aes_q(x=as.name(ContData.env$myName.DateTime)
, y=as.name(ContData.env$myName.AirTemp)
, color="air"), na.rm=TRUE) +
ggplot2::geom_path(ggplot2::aes_q(x=as.name(ContData.env$myName.DateTime)
,y=as.name(ContData.env$myName.WaterTemp)
, color="water", na.rm=TRUE)) +
ggplot2::scale_x_datetime(date_labels = "%Y-%m-%d") +
ggplot2::labs(title=mySiteID
, x=ContData.env$myLab.Date
, y=ContData.env$myLab.Temp.BOTH) +
ggplot2::theme(plot.title=ggplot2::element_text(hjust=0.5)
, plot.subtitle=ggplot2::element_text(hjust=0.5))
?geom_path
# ggplot, main
scale_lab   <- c("Air", "Water")
scale_col   <- c("green", "blue")
scale_fill  <- scale_col
scale_shape <- c(21, 21)
p2_t_aw <- ggplot2::ggplot(data=data.plot, ggplot2::aes(color="a"
, fill="b"
, shape="c")) +
ggplot2::geom_path(ggplot2::aes_q(x=as.name(ContData.env$myName.DateTime)
, y=as.name(ContData.env$myName.AirTemp)
, color="air")) +
ggplot2::geom_path(ggplot2::aes_q(x=as.name(ContData.env$myName.DateTime)
,y=as.name(ContData.env$myName.WaterTemp)
, color="water")) +
ggplot2::scale_x_datetime(date_labels = "%Y-%m-%d") +
ggplot2::labs(title=mySiteID
, x=ContData.env$myLab.Date
, y=ContData.env$myLab.Temp.BOTH) +
ggplot2::theme(plot.title=ggplot2::element_text(hjust=0.5)
, plot.subtitle=ggplot2::element_text(hjust=0.5))
p_t_aw
p2_t_aw
ggplot2::ggplot(data=data.plot, ggplot2::aes(color="a"
, fill="b"
, shape="c")) +
ggplot2::geom_path(ggplot2::aes_q(x=as.name(ContData.env$myName.DateTime)
, y=as.name(ContData.env$myName.AirTemp)
, color="air"))
ggplot2::ggplot(data=data.plot, ggplot2::aes(color="a"
, fill="b"
, shape="c")) +
ggplot2::geom_path(ggplot2::aes_q(x=as.name(ContData.env$myName.DateTime)
, y=as.name(ContData.env$myName.AirTemp)
, color="air")) +
ggplot2::geom_path(ggplot2::aes_q(x=as.name(ContData.env$myName.DateTime)
,y=as.name(ContData.env$myName.WaterTemp)
, color="water")) +
ggplot2::scale_x_datetime(date_labels = "%Y-%m-%d") +
ggplot2::labs(title=mySiteID
, x=ContData.env$myLab.Date
, y=ContData.env$myLab.Temp.BOTH) +
ggplot2::theme(plot.title=ggplot2::element_text(hjust=0.5)
, plot.subtitle=ggplot2::element_text(hjust=0.5))
myDiscrete <- paste(ContData.env$myPrefix.Discrete,i,sep=".")
if (myDiscrete %in% myParameters.ALL == TRUE){##IF.Discrete.START
p2_t_aw <- p2_t_aw + ggplot2::geom_point(data=data.plot
, ggplot2::aes_q(x=as.name(ContData.env$myName.DateTime)
, y=as.name(myDiscrete)
, color="discrete"
, shape="discrete"
, fill="discrete"), na.rm=TRUE)
} else {
p2_t_aw <- p2_t_aw + ggplot2::geom_blank(ggplot2::aes(color="discrete"
, shape="discrete"
, fill="discrete"))
}##IF.Discrete.
p2_t_aw
p2_t_aw +
ggplot2::scale_color_manual(name="Data Type", labels=c("air", "water", "discrete")
)
p2_t_aw +
ggplot2::scale_color_manual(name="Data Type", labels=c("air", "water", "discrete"), values=c("green", "blue", "black"))
?ContDataQC
# Examples of each operation
# Parameters
Selection.Operation <- c("GetGageData","QCRaw", "Aggregate", "SummaryStats")
Selection.Type      <- c("Air","Water","AW","Gage","AWG","AG","WG")
Selection.SUB <- c("Data0_Original", "Data1_RAW","Data2_QC","Data3_Aggregated","Data4_Stats")
myDir.BASE <- getwd()
# Create data directories
myDir.create <- paste0("./",Selection.SUB[1])
ifelse(dir.exists(myDir.create)==FALSE,dir.create(myDir.create),"Directory already exists")
myDir.create <- paste0("./",Selection.SUB[2])
ifelse(dir.exists(myDir.create)==FALSE,dir.create(myDir.create),"Directory already exists")
myDir.create <- paste0("./",Selection.SUB[3])
ifelse(dir.exists(myDir.create)==FALSE,dir.create(myDir.create),"Directory already exists")
myDir.create <- paste0("./",Selection.SUB[4])
ifelse(dir.exists(myDir.create)==FALSE,dir.create(myDir.create),"Directory already exists")
myDir.create <- paste0("./",Selection.SUB[5])
ifelse(dir.exists(myDir.create)==FALSE,dir.create(myDir.create),"Directory already exists")
# Save example data (assumes directory ./Data1_RAW/ exists)
myData <- data_raw_test2_AW_20130426_20130725
write.csv(myData,paste0("./",Selection.SUB[2],"/test2_AW_20130426_20130725.csv"))
myData <- data_raw_test2_AW_20130725_20131015
write.csv(myData,paste0("./",Selection.SUB[2],"/test2_AW_20130725_20131015.csv"))
myData <- data_raw_test2_AW_20140901_20140930
write.csv(myData,paste0("./",Selection.SUB[2],"/test2_AW_20140901_20140930.csv"))
myData <- data_raw_test4_AW_20160418_20160726
write.csv(myData,paste0("./",Selection.SUB[2],"/test4_AW_20160418_20160726.csv"))
myFile <- "config.TZ.Central.R"
file.copy(file.path(path.package("ContDataQC"),"extdata",myFile)
,file.path(getwd(),Selection.SUB[2],myFile))
# QC Raw Data
myData.Operation <- "QCRaw" #Selection.Operation[2]
myData.SiteID    <- "test2"
myData.Type      <- Selection.Type[3] #"AW"
myData.DateRange.Start  <- "2013-01-01"
myData.DateRange.End    <- "2014-12-31"
myDir.import <- file.path(myDir.BASE,Selection.SUB[2]) #"Data1_RAW"
myDir.export <- file.path(myDir.BASE,Selection.SUB[3]) #"Data2_QC"
myReport.format <- "docx"
ContDataQC(myData.Operation, myData.SiteID, myData.Type, myData.DateRange.Start
, myData.DateRange.End, myDir.import, myDir.export
, fun.myReport.format=myReport.format)
# QC Raw Data (offset collection times for air and water sensors)
myData.Operation <- "QCRaw" #Selection.Operation[2]
myData.SiteID    <- "test4"
myData.Type      <- Selection.Type[3] #"AW"
myData.DateRange.Start  <- "2016-04-28"
myData.DateRange.End    <- "2016-07-26"
myDir.import <- file.path(myDir.BASE,Selection.SUB[2]) #"Data1_RAW"
myDir.export <- file.path(myDir.BASE,Selection.SUB[3]) #"Data2_QC"
myReport.format <- "html"
ContDataQC(myData.Operation, myData.SiteID, myData.Type, myData.DateRange.Start
, myData.DateRange.End, myDir.import, myDir.export
, fun.myReport.format=myReport.format)
# Aggregate Data
myData.Operation <- "Aggregate" #Selection.Operation[3]
myData.SiteID    <- "test2"
myData.Type      <- Selection.Type[3] #"AW"
myData.DateRange.Start  <- "2013-01-01"
myData.DateRange.End    <- "2014-12-31"
myDir.import <- file.path(myDir.BASE,Selection.SUB[3]) #"Data2_QC"
myDir.export <- file.path(myDir.BASE,Selection.SUB[4]) #"Data3_Aggregated"
#Leave off myReport.format and get default (docx).
ContDataQC(myData.Operation, myData.SiteID, myData.Type, myData.DateRange.Start
, myData.DateRange.End, myDir.import, myDir.export)
# Summary Stats
myData.Operation <- "SummaryStats" #Selection.Operation[4]
myData.SiteID    <- "test2"
myData.Type      <- Selection.Type[3] #"AW"
myData.DateRange.Start  <- "2013-01-01"
myData.DateRange.End    <- "2014-12-31"
myDir.import <- file.path(myDir.BASE,Selection.SUB[4]) #"Data3_Aggregated"
myDir.export <- file.path(myDir.BASE,Selection.SUB[5]) #"Data4_Stats"
#Leave off myReport.format and get default (docx).
ContDataQC(myData.Operation, myData.SiteID, myData.Type, myData.DateRange.Start
, myData.DateRange.End, myDir.import, myDir.export)
# NEWS
# Render then Copy NEWS so picked up in help
rmarkdown::render("NEWS.rmd", "all")
file.copy("NEWS.md", "NEWS", overwrite = TRUE)
file.remove("NEWS.html")
file.remove("NEWS.md")
#
# Library Name
myLibrary <- "ContDataQC"
# Load Library
library(devtools)
#~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
# Create Package
# create(myLibrary)
#~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
#
#~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
# Document, Install, and Reload Library
## Generate Documentation
setwd(paste0("./",myLibrary))
devtools::document()
## Install New Package (locally)
setwd("..") # return to root directory first
devtools::install(myLibrary)
## Reload library
library(myLibrary,character.only = TRUE)
# change wd back to package
setwd(paste0("./",myLibrary))
pkg <- "ContDataQC"
library(pkg, character.only = TRUE)
help(package=(pkg))
# NEWS
# Render then Copy NEWS so picked up in help
rmarkdown::render("NEWS.rmd", "all")
file.copy("NEWS.md", "NEWS", overwrite = TRUE)
file.remove("NEWS.html")
file.remove("NEWS.md")
#
# Library Name
myLibrary <- "ContDataQC"
# Load Library
library(devtools)
#~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
# Create Package
# create(myLibrary)
#~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
#
#~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
# Document, Install, and Reload Library
## Generate Documentation
setwd(paste0("./",myLibrary))
devtools::document()
## Install New Package (locally)
setwd("..") # return to root directory first
devtools::install(myLibrary)
## Reload library
library(myLibrary,character.only = TRUE)
# change wd back to package
setwd(paste0("./",myLibrary))
pkg <- "ContDataQC"
library(pkg, character.only = TRUE)
help(package=(pkg))
