# QC date and time
# accessing files with Excel can change formats
# 20170116, EWL
data.import <- fun.QC.datetime(data.import)
# Define time period fields
myNames.Fields.TimePeriods <- c(ContData.env$myName.Yr, ContData.env$myName.YrMo, ContData.env$myName.MoDa, ContData.env$myName.Mo
, ContData.env$myName.JuDa, ContData.env$myName.Season, ContData.env$myName.YrSeason)
# add time period fields
data.import[,ContData.env$myName.Yr]   <- format(as.Date(data.import[,ContData.env$myName.Date]),format="%Y")
data.import[,ContData.env$myName.Mo]   <- format(as.Date(data.import[,ContData.env$myName.Date]),format="%m")
data.import[,ContData.env$myName.YrMo] <- format(as.Date(data.import[,ContData.env$myName.Date]),format="%Y%m")
data.import[,ContData.env$myName.MoDa] <- format(as.Date(data.import[,ContData.env$myName.Date]),format="%m%d")
data.import[,ContData.env$myName.JuDa] <- as.POSIXlt(data.import[,ContData.env$myName.Date], format=ContData.env$myFormat.Date)$yday +1
## add Season fields
#   md <- data.import[,myName.MoDa]
#   data.import[,myName.Season] <- NA
#   data.import[,myName.Season][as.numeric(md)>=as.numeric("0101") & as.numeric(md)<as.numeric(myTimeFrame.Season.Spring.Start)] <- "Winter"
#   data.import[,myName.Season][as.numeric(md)>=as.numeric(myTimeFrame.Season.Spring.Start) & as.numeric(md)<as.numeric(myTimeFrame.Season.Summer.Start)] <- "Spring"
#   data.import[,myName.Season][as.numeric(md)>=as.numeric(myTimeFrame.Season.Summer.Start) & as.numeric(md)<as.numeric(myTimeFrame.Season.Fall.Start)] <- "Summer"
#   data.import[,myName.Season][as.numeric(md)>=as.numeric(myTimeFrame.Season.Fall.Start) & as.numeric(md)<as.numeric(myTimeFrame.Season.Winter.Start)] <- "Fall"
#   data.import[,myName.Season][as.numeric(md)>=as.numeric(myTimeFrame.Season.Winter.Start) & as.numeric(md)<as.numeric("1231")] <- "Winter"
#   data.import[,myName.SeasonYr] <- paste(data.import[,"Season"],data.import[,"Year"],sep="")
data.import[,ContData.env$myName.Season] <- NA
data.import[,ContData.env$myName.Season][as.numeric(data.import[,ContData.env$myName.MoDa])>=as.numeric("0101") & as.numeric(data.import[,ContData.env$myName.MoDa])<as.numeric(ContData.env$myTimeFrame.Season.Spring.Start)] <- "Winter"
data.import[,ContData.env$myName.Season][as.numeric(data.import[,ContData.env$myName.MoDa])>=as.numeric(ContData.env$myTimeFrame.Season.Spring.Start) & as.numeric(data.import[,ContData.env$myName.MoDa])<as.numeric(ContData.env$myTimeFrame.Season.Summer.Start)] <- "Spring"
data.import[,ContData.env$myName.Season][as.numeric(data.import[,ContData.env$myName.MoDa])>=as.numeric(ContData.env$myTimeFrame.Season.Summer.Start) & as.numeric(data.import[,ContData.env$myName.MoDa])<as.numeric(ContData.env$myTimeFrame.Season.Fall.Start)] <- "Summer"
data.import[,ContData.env$myName.Season][as.numeric(data.import[,ContData.env$myName.MoDa])>=as.numeric(ContData.env$myTimeFrame.Season.Fall.Start) & as.numeric(data.import[,ContData.env$myName.MoDa])<as.numeric(ContData.env$myTimeFrame.Season.Winter.Start)] <- "Fall"
data.import[,ContData.env$myName.Season][as.numeric(data.import[,ContData.env$myName.MoDa])>=as.numeric(ContData.env$myTimeFrame.Season.Winter.Start) & as.numeric(data.import[,ContData.env$myName.MoDa])<as.numeric("1231")] <- "Winter"
data.import[,ContData.env$myName.YrSeason] <- paste(data.import[,ContData.env$myName.Yr],data.import[,ContData.env$myName.Season],sep="")
#
# Loop - Parameter (n=3)
## Temperature (Air/Water)
## Flow (SensorDepth and Discharge)
## Nothing on Pressure (used to calculate SensorDepth)
# future add pH, Cond, etc from USGS gages
myFields.Data       <- c(ContData.env$myName.WaterTemp, ContData.env$myName.AirTemp, ContData.env$myName.SensorDepth)
myFields.Data.Flags <- c(ContData.env$myName.Flag.WaterTemp, ContData.env$myName.Flag.AirTemp, ContData.env$myName.Flag.SensorDepth)
myFields.Type       <- c("Thermal","Thermal","Hydrologic")
myFields.Keep <- c(ContData.env$myName.SiteID
, ContData.env$myName.Date
, ContData.env$myName.Time
, ContData.env$myName.DateTime
, ContData.env$myNames.Fields.TimePeriods
, ContData.env$myFields.Data
, ContData.env$myFields.Data.Flags
)
# keep only fields needed for stats
# data.import <- data.import[,myFields.Keep]
#~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
data2process <- myFields.Data[myFields.Data %in% names(data.import)]
print(paste("Total items to process = ",length(data2process),":",sep=""))
print(data2process)
flush.console()
############## QC
#i <- data2process[1] #QC
#######################
i.num <- match(i,myFields.Data)
data2process
i <- data2process[1]
i
i.num <- match(i,myFields.Data)
Fields2Drop <- myFields.Data[-i.num]
data.stats <- data.import[,!(names(data.import) %in% Fields2Drop)]
# change fails to NA (so can na.rm=T when run stats)
# flag field
myFlag <- myFields.Data.Flags[i.num]
#data.stats.nofail <- data.stats[data.stats[,myFields.Data.Flags[i.num]]!=myFlagVal.Fail,]
# 20180519, feedback to user
print(paste0("Processing item ",i.num," of ",length(data2process),"; ",i))
flush.console()
#data.stats.nofail <- data.stats
#data.stats.nofail[data.stats.nofail[,data.stats[,myFields.Data.Flags[i.num]]=myFlagVal.Fail]] <- na
# change fail to NA for i (only if user define value == FALSE)
if(ContData.env$myStats.Fails.Exclude==TRUE) {##IF.myStats.Fails.Include.START
#
data.stats[,i][data.stats[,myFlag]==ContData.env$myFlagVal.Fail] <- NA
#
}##IF.myStats.Fails.Exclude.END
#QC test where fails
qc.section <- "For.i.A"
print(paste0("QC.Section: ",qc.section))
flush.console()
#
# summaryBy doesn't work with Group as variable (change value for running here)
# have to change some back for dv.i when save
names(data.stats)[names(data.stats) %in% ContData.env$myName.Date] <- "Date"
names(data.stats)[names(data.stats) %in% ContData.env$myName.YrMo] <- "YearMonth"
names(data.stats)[names(data.stats) %in% ContData.env$myName.YrSeason] <- "YearSeason"
names(data.stats)[names(data.stats) %in% ContData.env$myName.Yr] <- "Year"
#QC test where fails
qc.section <- "For.i.B.namechanges"
print(paste0("QC.Section: ",qc.section))
flush.console()
dv.i <- doBy::summaryBy(as.numeric(data.stats[,i])~Date, data=data.stats, FUN=c(mean), na.rm=TRUE, var.names="i"
, id=c(ContData.env$myName.SiteID, ContData.env$myName.Yr , ContData.env$myName.YrMo
, ContData.env$myName.Mo, ContData.env$myName.MoDa , ContData.env$myName.JuDa
, ContData.env$myName.Season,ContData.env$myName.YrSeason)
)
dv.i
as.numeric(data.stats[,i])
##~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
# Library Name
myLibrary <- "ContDataQC" # "ContDataQC","MMIcalc","MMIcalcNV","MBSStools","XC95"
# Load Library
library(devtools)
#~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
# Create Package
# create(myLibrary)
#~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
# files to library folder
# file.copy("metric.values.R","./Library/MMIcalc/R/metric.values.R",overwrite=TRUE)
#~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
#
#~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
# Document, Install, and Reload Library
## Generate Documentation
setwd(paste0("./",myLibrary))
devtools::document()
## Install New Package (locally)
setwd("..") # return to root directory first
devtools::install(myLibrary)
## Reload library
library(myLibrary,character.only = TRUE)
# change wd back to package
setwd(paste0("./",myLibrary))
library(ContDataQC)
?ContDataQC
# Parameters
Selection.Operation <- c("GetGageData","QCRaw", "Aggregate", "SummaryStats")
Selection.Type      <- c("Air","Water","AW","Gage","AWG","AG","WG")
Selection.SUB <- c("Data1_RAW","Data2_QC","Data3_Aggregated","Data4_Stats")
myDir.SUB.import <- ""
myDir.SUB.export <- ""
# Summary Stats
myData.Operation <- "SummaryStats" #Selection.Operation[4]
myData.SiteID    <- "test2"
myData.Type      <- Selection.Type[3] #"AW"
myData.DateRange.Start  <- "2013-01-01"
myData.DateRange.End    <- "2014-12-31"
myDir.SUB.import <- Selection.SUB[3] #"Data3_Aggregated"
myDir.SUB.export <- Selection.SUB[4] #"Data4_Stats"
ContDataQC(myData.Operation, myData.SiteID, myData.Type, myData.DateRange.Start, myData.DateRange.End, getwd(), "", "", "")
#~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
# Library Name
myLibrary <- "ContDataQC" # "ContDataQC","MMIcalc","MMIcalcNV","MBSStools","XC95"
# Load Library
library(devtools)
#~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
# Create Package
# create(myLibrary)
#~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
# files to library folder
# file.copy("metric.values.R","./Library/MMIcalc/R/metric.values.R",overwrite=TRUE)
#~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
#
#~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
# Document, Install, and Reload Library
## Generate Documentation
setwd(paste0("./",myLibrary))
devtools::document()
## Install New Package (locally)
setwd("..") # return to root directory first
devtools::install(myLibrary)
## Reload library
library(myLibrary,character.only = TRUE)
# change wd back to package
setwd(paste0("./",myLibrary))
#~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
library(ContDataQC)
?ContDataQC
# Parameters
Selection.Operation <- c("GetGageData","QCRaw", "Aggregate", "SummaryStats")
Selection.Type      <- c("Air","Water","AW","Gage","AWG","AG","WG")
Selection.SUB <- c("Data1_RAW","Data2_QC","Data3_Aggregated","Data4_Stats")
myDir.SUB.import <- ""
myDir.SUB.export <- ""
# Summary Stats
myData.Operation <- "SummaryStats" #Selection.Operation[4]
myData.SiteID    <- "test2"
myData.Type      <- Selection.Type[3] #"AW"
myData.DateRange.Start  <- "2013-01-01"
myData.DateRange.End    <- "2014-12-31"
myDir.SUB.import <- Selection.SUB[3] #"Data3_Aggregated"
myDir.SUB.export <- Selection.SUB[4] #"Data4_Stats"
ContDataQC(myData.Operation, myData.SiteID, myData.Type, myData.DateRange.Start, myData.DateRange.End, getwd(), "", "", "")
head(data.stats)
# 0. SetUp ####
# Check WD
getwd()
# if recreated packaged
# Restart R within RStudio:  Ctrl + Shift + F10
library(ContDataQC)
?ContDataQC
# 1. Parameters ####
source("./R/config.R") # need to load since not accessing script
source("./R/fun.DateFormat.R")
source("./R/fun.Helper.R")
# From ContDataQC() examples
# Parameters
Selection.Operation <- c("GetGageData","QCRaw", "Aggregate", "SummaryStats")
Selection.Type      <- c("Air","Water","AW","Gage","AWG","AG","WG")
myData.DateRange.Start  <- "2013-01-01"
myData.DateRange.End    <- "2014-12-31"
Selection.SUB <- c("Data1_RAW","Data2_QC","Data3_Aggregated","Data4_Stats")
myDir.SUB.import <- ""
myDir.SUB.export <- ""
# Summary Stats
myData.Operation <- "SummaryStats" #Selection.Operation[4]
myData.SiteID    <- "test2"
myData.Type      <- Selection.Type[3] #"AW"
myData.DateRange.Start  <- "2013-01-01"
myData.DateRange.End    <- "2014-12-31"
myDir.SUB.import <- Selection.SUB[3] #"Data3_Aggregated"
myDir.SUB.export <- Selection.SUB[4] #"Data4_Stats"
#ContDataQC(myData.Operation, myData.SiteID, myData.Type, myData.DateRange.Start, myData.DateRange.End, getwd(), "", "", "")
# 2. fun.Stats.R ####
# fun.Stats <- function(fun.myData.SiteID
#                       ,fun.myData.Type
#                       ,fun.myData.DateRange.Start
#                       ,fun.myData.DateRange.End
#                       ,fun.myDir.BASE=getwd()
#                       ,fun.myDir.SUB.import=""
#                       ,fun.myDir.SUB.export=""
#                       ,fun.myProcedure.Step
#                       ,fun.myFile.Prefix)
fun.myData.SiteID <- myData.SiteID
fun.myData.Type <- myData.Type
fun.myData.DateRange.Start <- myData.DateRange.Start
fun.myData.DateRange.End <- myData.DateRange.End
fun.myDir.BASE <- getwd()
fun.myDir.SUB.import <- Selection.SUB[3] #"Data3_Aggregated"
fun.myDir.SUB.export <- Selection.SUB[4] #"Data4_Stats"
fun.myProcedure.Step <- "Stats"
fun.myFile.Prefix <- "DATA"
#
# Error Checking - only 1 SiteID and 1 DataType
if(length(fun.myData.SiteID)!=1){
myMsg <- "Function can only handle 1 SiteID."
stop(myMsg)
}
if(length(fun.myData.Type)!=1){
myMsg <- "Function can only handle 1 Data Type."
stop(myMsg)
}
#
# Convert Data Type to proper case
fun.myData.Type <- paste(toupper(substring(fun.myData.Type,1,1)),tolower(substring(fun.myData.Type,2,nchar(fun.myData.Type))),sep="")
#
# data directories
myDir.data.import <- paste(fun.myDir.BASE,ifelse(fun.myDir.SUB.import=="","",paste("/",fun.myDir.SUB.import,sep="")),sep="")
myDir.data.export <- paste(fun.myDir.BASE,ifelse(fun.myDir.SUB.export=="","",paste("/",fun.myDir.SUB.export,sep="")),sep="")
#
myDate <- format(Sys.Date(),"%Y%m%d")
myTime <- format(Sys.time(),"%H%M%S")
#
# Verify input dates, if blank, NA, or null use all data
# if DateRange.Start is null or "" then assign it 1900-01-01
if (is.na(fun.myData.DateRange.Start)==TRUE||fun.myData.DateRange.Start==""){fun.myData.DateRange.Start<-ContData.env$DateRange.Start.Default}
# if DateRange.End is null or "" then assign it today
if (is.na(fun.myData.DateRange.End)==TRUE||fun.myData.DateRange.End==""){fun.myData.DateRange.End<-ContData.env$DateRange.End.Default}
#
# 0. Load Single file
strFile.Prefix     <- toupper(fun.myFile.Prefix)     # DATA = Aggregate, QC = QC
strFile.SiteID     <- fun.myData.SiteID
strFile.DataType   <- fun.myData.Type
strFile.Date.Start <- format(as.Date(fun.myData.DateRange.Start,"%Y-%m-%d"),"%Y%m%d")
strFile.Date.End   <- format(as.Date(fun.myData.DateRange.End,"%Y-%m-%d"),"%Y%m%d")
strFile <- paste(paste(strFile.Prefix,strFile.SiteID,fun.myData.Type,strFile.Date.Start,strFile.Date.End,sep=ContData.env$myDelim),"csv",sep=".")
strFile.Base <- substr(strFile,1,nchar(strFile)-nchar(".csv"))
strFile.parts <- strsplit(strFile.Base, ContData.env$myDelim)
#
#QC, make sure file exists
if(strFile %in% list.files(path=myDir.data.import)==FALSE) {##IF.file.START
#
print("ERROR; no such file exits.  Cannot generate summary statistics.")
print(paste("PATH = ",myDir.data.import,sep=""))
print(paste("FILE = ",strFile,sep=""))
flush.console()
# maybe print similar files
stop("Bad file.")
#
}##IF.file.END
#import the file
data.import <- read.csv(paste(myDir.data.import,strFile,sep="/"),as.is=TRUE,na.strings="")
#
# QC required fields: SiteID & (DateTime | (Date & Time))
fun.QC.ReqFlds(names(data.import),paste(myDir.data.import,strFile,sep="/"))
#
#
# QC date and time
# accessing files with Excel can change formats
# 20170116, EWL
data.import <- fun.QC.datetime(data.import)
# Define time period fields
myNames.Fields.TimePeriods <- c(ContData.env$myName.Yr, ContData.env$myName.YrMo, ContData.env$myName.MoDa, ContData.env$myName.Mo
, ContData.env$myName.JuDa, ContData.env$myName.Season, ContData.env$myName.YrSeason)
# add time period fields
data.import[,ContData.env$myName.Yr]   <- format(as.Date(data.import[,ContData.env$myName.Date]),format="%Y")
data.import[,ContData.env$myName.Mo]   <- format(as.Date(data.import[,ContData.env$myName.Date]),format="%m")
data.import[,ContData.env$myName.YrMo] <- format(as.Date(data.import[,ContData.env$myName.Date]),format="%Y%m")
data.import[,ContData.env$myName.MoDa] <- format(as.Date(data.import[,ContData.env$myName.Date]),format="%m%d")
data.import[,ContData.env$myName.JuDa] <- as.POSIXlt(data.import[,ContData.env$myName.Date], format=ContData.env$myFormat.Date)$yday +1
## add Season fields
#   md <- data.import[,myName.MoDa]
#   data.import[,myName.Season] <- NA
#   data.import[,myName.Season][as.numeric(md)>=as.numeric("0101") & as.numeric(md)<as.numeric(myTimeFrame.Season.Spring.Start)] <- "Winter"
#   data.import[,myName.Season][as.numeric(md)>=as.numeric(myTimeFrame.Season.Spring.Start) & as.numeric(md)<as.numeric(myTimeFrame.Season.Summer.Start)] <- "Spring"
#   data.import[,myName.Season][as.numeric(md)>=as.numeric(myTimeFrame.Season.Summer.Start) & as.numeric(md)<as.numeric(myTimeFrame.Season.Fall.Start)] <- "Summer"
#   data.import[,myName.Season][as.numeric(md)>=as.numeric(myTimeFrame.Season.Fall.Start) & as.numeric(md)<as.numeric(myTimeFrame.Season.Winter.Start)] <- "Fall"
#   data.import[,myName.Season][as.numeric(md)>=as.numeric(myTimeFrame.Season.Winter.Start) & as.numeric(md)<as.numeric("1231")] <- "Winter"
#   data.import[,myName.SeasonYr] <- paste(data.import[,"Season"],data.import[,"Year"],sep="")
data.import[,ContData.env$myName.Season] <- NA
data.import[,ContData.env$myName.Season][as.numeric(data.import[,ContData.env$myName.MoDa])>=as.numeric("0101") & as.numeric(data.import[,ContData.env$myName.MoDa])<as.numeric(ContData.env$myTimeFrame.Season.Spring.Start)] <- "Winter"
data.import[,ContData.env$myName.Season][as.numeric(data.import[,ContData.env$myName.MoDa])>=as.numeric(ContData.env$myTimeFrame.Season.Spring.Start) & as.numeric(data.import[,ContData.env$myName.MoDa])<as.numeric(ContData.env$myTimeFrame.Season.Summer.Start)] <- "Spring"
data.import[,ContData.env$myName.Season][as.numeric(data.import[,ContData.env$myName.MoDa])>=as.numeric(ContData.env$myTimeFrame.Season.Summer.Start) & as.numeric(data.import[,ContData.env$myName.MoDa])<as.numeric(ContData.env$myTimeFrame.Season.Fall.Start)] <- "Summer"
data.import[,ContData.env$myName.Season][as.numeric(data.import[,ContData.env$myName.MoDa])>=as.numeric(ContData.env$myTimeFrame.Season.Fall.Start) & as.numeric(data.import[,ContData.env$myName.MoDa])<as.numeric(ContData.env$myTimeFrame.Season.Winter.Start)] <- "Fall"
data.import[,ContData.env$myName.Season][as.numeric(data.import[,ContData.env$myName.MoDa])>=as.numeric(ContData.env$myTimeFrame.Season.Winter.Start) & as.numeric(data.import[,ContData.env$myName.MoDa])<as.numeric("1231")] <- "Winter"
data.import[,ContData.env$myName.YrSeason] <- paste(data.import[,ContData.env$myName.Yr],data.import[,ContData.env$myName.Season],sep="")
#
# Loop - Parameter (n=3)
## Temperature (Air/Water)
## Flow (SensorDepth and Discharge)
## Nothing on Pressure (used to calculate SensorDepth)
# future add pH, Cond, etc from USGS gages
myFields.Data       <- c(ContData.env$myName.WaterTemp, ContData.env$myName.AirTemp, ContData.env$myName.SensorDepth)
myFields.Data.Flags <- c(ContData.env$myName.Flag.WaterTemp, ContData.env$myName.Flag.AirTemp, ContData.env$myName.Flag.SensorDepth)
myFields.Type       <- c("Thermal","Thermal","Hydrologic")
myFields.Keep <- c(ContData.env$myName.SiteID
, ContData.env$myName.Date
, ContData.env$myName.Time
, ContData.env$myName.DateTime
, ContData.env$myNames.Fields.TimePeriods
, ContData.env$myFields.Data
, ContData.env$myFields.Data.Flags
)
# keep only fields needed for stats
# data.import <- data.import[,myFields.Keep]
#~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
data2process <- myFields.Data[myFields.Data %in% names(data.import)]
print(paste("Total items to process = ",length(data2process),":",sep=""))
print(data2process)
flush.console()
i <- data2process[1]
i.num <- match(i,myFields.Data)
Fields2Drop <- myFields.Data[-i.num]
data.stats <- data.import[,!(names(data.import) %in% Fields2Drop)]
# change fails to NA (so can na.rm=T when run stats)
# flag field
myFlag <- myFields.Data.Flags[i.num]
#data.stats.nofail <- data.stats[data.stats[,myFields.Data.Flags[i.num]]!=myFlagVal.Fail,]
# 20180519, feedback to user
print(paste0("Processing item ",i.num," of ",length(data2process),"; ",i))
flush.console()
#data.stats.nofail <- data.stats
#data.stats.nofail[data.stats.nofail[,data.stats[,myFields.Data.Flags[i.num]]=myFlagVal.Fail]] <- na
# change fail to NA for i (only if user define value == FALSE)
if(ContData.env$myStats.Fails.Exclude==TRUE) {##IF.myStats.Fails.Include.START
#
data.stats[,i][data.stats[,myFlag]==ContData.env$myFlagVal.Fail] <- NA
#
}##IF.myStats.Fails.Exclude.END
#QC test where fails
qc.section <- "For.i.A"
print(paste0("QC.Section: ",qc.section))
flush.console()
#
# summaryBy doesn't work with Group as variable (change value for running here)
# have to change some back for dv.i when save
names(data.stats)[names(data.stats) %in% ContData.env$myName.Date] <- "Date"
names(data.stats)[names(data.stats) %in% ContData.env$myName.YrMo] <- "YearMonth"
names(data.stats)[names(data.stats) %in% ContData.env$myName.YrSeason] <- "YearSeason"
names(data.stats)[names(data.stats) %in% ContData.env$myName.Yr] <- "Year"
#QC test where fails
qc.section <- "For.i.B.namechanges"
print(paste0("QC.Section: ",qc.section))
flush.console()
# summaryBy not working with "i" as variable.  Have to do an ugly hack to get it working
#     # QC
#     print("test2")
#     print(i)
#     print("data.stats")
#     print(head(data.stats))
#     flush.console()
#
#
#     data(dietox)
#     dietox12    <- subset(dietox,Time==12)
#     j <- "Weight"
#
#     x<-doBy::summaryBy(as.numeric(Weight)+Feed~Evit+Cu, data=dietox12,
#               FUN=c(mean,var,length))
#
#     print(x)
#     flush.console()
#
#    # myDF <- data.stats
#     #x <- summaryBy(as.numeric(Water.Temp.C)~Date,data=myDF,FUN=c(mean),na.rm=TRUE)
#     #print(dim(x))
# Create Daily Values (mean) (DV is USGS term so use that)
# if(i==myFields.Data[1]) {
# dv.i <- doBy::summaryBy(as.numeric(Water.Temp.C)~Date, data=data.stats, FUN=c(mean), na.rm=TRUE
#                   , var.names="i",id=c(ContData.env$myName.SiteID, "Year", "YearMonth", ContData.env$myName.Mo, ContData.env$myName.MoDa
#                                        , ContData.env$myName.JuDa, ContData.env$myName.Season,"YearSeason"))
# } else if(i==myFields.Data[2]) {
#   dv.i <- doBy::summaryBy(as.numeric(Air.Temp.C)~Date, data=data.stats, FUN=c(mean), na.rm=TRUE
#                     , var.names="i",id=c(ContData.env$myName.SiteID, "Year", "YearMonth", ContData.env$myName.Mo, ContData.env$myName.MoDa
#                                          , ContData.env$myName.JuDa, ContData.env$myName.Season,"YearSeason"))
# } else if (i==myFields.Data[3]) {
#   dv.i <- doBy::summaryBy(as.numeric(Water.Level.ft)~Date, data=data.stats, FUN=c(mean), na.rm=TRUE
#                     , var.names="i",id=c(ContData.env$myName.SiteID, "Year", "YearMonth", ContData.env$myName.Mo, ContData.env$myName.MoDa
#                                          , ContData.env$myName.JuDa, ContData.env$myName.Season,"YearSeason"))
# }
# 2017015, fix hard coded names
# if(i==myFields.Data[1]) {
#   dv.i <- doBy::summaryBy(as.numeric(data.stats[,ContData.env$myName.WaterTemp])~Date, data=data.stats, FUN=c(mean), na.rm=TRUE
#                           , var.names="i",id=c(ContData.env$myName.SiteID, ContData.env$myName.Yr , ContData.env$myName.YrMo, ContData.env$myName.Mo, ContData.env$myName.MoDa
#                                                , ContData.env$myName.JuDa, ContData.env$myName.Season,ContData.env$myName.YrSeason))
# } else if(i==myFields.Data[2]) {
#   dv.i <- doBy::summaryBy(as.numeric(data.stats[,ContData.env$myName.AirTemp])~Date, data=data.stats, FUN=c(mean), na.rm=TRUE
#                           , var.names="i",id=c(ContData.env$myName.SiteID, ContData.env$myName.Yr , ContData.env$myName.YrMo, ContData.env$myName.Mo, ContData.env$myName.MoDa
#                                                , ContData.env$myName.JuDa, ContData.env$myName.Season,ContData.env$myName.YrSeason))
# } else if (i==myFields.Data[3]) {
#   dv.i <- doBy::summaryBy(as.numeric(data.stats[,ContData.env$myName.SensorDepth])~Date, data=data.stats, FUN=c(mean), na.rm=TRUE
#                           , var.names="i",id=c(ContData.env$myName.SiteID, ContData.env$myName.Yr , ContData.env$myName.YrMo, ContData.env$myName.Mo, ContData.env$myName.MoDa
#                                                , ContData.env$myName.JuDa, ContData.env$myName.Season,ContData.env$myName.YrSeason))
# }
# 20170519, don't need "if" statement above.
# dv.i <- doBy::summaryBy(as.numeric(data.stats[,i])~Date, data=data.stats, FUN=c(mean), na.rm=TRUE, var.names="i"
#                         , id=c(ContData.env$myName.SiteID, ContData.env$myName.Yr , ContData.env$myName.YrMo
#                               , ContData.env$myName.Mo, ContData.env$myName.MoDa , ContData.env$myName.JuDa
#
dv.i <- doBy::summaryBy(as.numeric(data.stats[,i])~Date, data=data.stats, FUN=c(mean), na.rm=TRUE, var.names="i"
, id=c(ContData.env$myName.SiteID)
)
head(dv.i)
dv.i <- doBy::summaryBy(as.numeric(data.stats[,i])~Date, data=data.stats, FUN=c(mean), na.rm=TRUE, var.names="i"
, id=c(ContData.env$myName.SiteID, ContData.env$myName.Yr, ContData.env$myName.YrMo
, ContData.env$myName.Mo, ContData.env$myName.MoDa, ContData.env$myName.JuDa
, ContData.env$myName.Season,ContData.env$myName.YrSeason)
)
head(dv.i)
?switch
#~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
# Library Name
myLibrary <- "ContDataQC" # "ContDataQC","MMIcalc","MMIcalcNV","MBSStools","XC95"
# Load Library
library(devtools)
#~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
# Create Package
# create(myLibrary)
#~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
# files to library folder
# file.copy("metric.values.R","./Library/MMIcalc/R/metric.values.R",overwrite=TRUE)
#~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
#
#~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
# Document, Install, and Reload Library
## Generate Documentation
setwd(paste0("./",myLibrary))
devtools::document()
## Install New Package (locally)
setwd("..") # return to root directory first
devtools::install(myLibrary)
## Reload library
library(myLibrary,character.only = TRUE)
# change wd back to package
setwd(paste0("./",myLibrary))
#~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
#
library(ContDataQC)
?ContDataQC
# Parameters
Selection.Operation <- c("GetGageData","QCRaw", "Aggregate", "SummaryStats")
Selection.Type      <- c("Air","Water","AW","Gage","AWG","AG","WG")
Selection.SUB <- c("Data1_RAW","Data2_QC","Data3_Aggregated","Data4_Stats")
myDir.SUB.import <- ""
myDir.SUB.export <- ""
# Summary Stats
myData.Operation <- "SummaryStats" #Selection.Operation[4]
myData.SiteID    <- "test2"
myData.Type      <- Selection.Type[3] #"AW"
myData.DateRange.Start  <- "2013-01-01"
myData.DateRange.End    <- "2014-12-31"
myDir.SUB.import <- Selection.SUB[3] #"Data3_Aggregated"
myDir.SUB.export <- Selection.SUB[4] #"Data4_Stats"
ContDataQC(myData.Operation, myData.SiteID, myData.Type, myData.DateRange.Start, myData.DateRange.End, getwd(), "", "", "")
##~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
# Library Name
myLibrary <- "ContDataQC" # "ContDataQC","MMIcalc","MMIcalcNV","MBSStools","XC95"
# Load Library
library(devtools)
#~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
# Create Package
# create(myLibrary)
#~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
# files to library folder
# file.copy("metric.values.R","./Library/MMIcalc/R/metric.values.R",overwrite=TRUE)
#~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
#
#~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
# Document, Install, and Reload Library
## Generate Documentation
setwd(paste0("./",myLibrary))
devtools::document()
## Install New Package (locally)
setwd("..") # return to root directory first
devtools::install(myLibrary)
## Reload library
library(myLibrary,character.only = TRUE)
# change wd back to package
setwd(paste0("./",myLibrary))
#~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
