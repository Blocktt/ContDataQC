#
# variable for following block
myField.T1 <- myField
#
# A.2. Calc, SD, calc SD of last 25 hours
myCalc <- "SD"
myField <- paste(fun.myField.Data,myCalc,sep=".")
#myField.T2 <- myName.DateTime
#   ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
#   # calc SD
#   #
#   #a <- fun.data.import.mod[,myName.WaterTemp]
#   #b <- fun.data.import.mod[,myName.DateTime]
#   #sd(a[b<="2014-04-22 10:00:00" & b>="2014-01-13 11:00:00"],na.rm=TRUE)
#   #sd(a,na.rm=TRUE)
#   #
#   fun.data.import.mod[,myField] <- sd(fun.data.import.mod[,fun.myField.Data][fun.data.import.mod[,myName.DateTime]<="2014-04-22 10:00:00" & fun.data.import.mod[,myName.DateTime]>="2014-01-13 11:00:00"],na.rm=TRUE)
# ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
## zoo version with rollapply
# need at least 5 records
if(nrow(fun.data.import.mod)<5) {##IF.nrow.START
myMsg <- paste("\n
The data file has less than 5 records.
The scripts will not work properly until you have more data."
,sep="")
stop(myMsg)
}##IF.1.END
# get interval distance (will crash if less than 5 records)
# myT.diff <- difftime(fun.data.import.mod[5,ContData.env$myName.DateTime],fun.data.import.mod[4,ContData.env$myName.DateTime],units="mins")
# myT.diff[[1]]
# use median of all (no lower limit)
#x <- strptime(fun.data.import.mod[,ContData.env$myName.DateTime],format=ContData.env$myFormat.DateTime)
#myT <- strptime(fun.data.import.mod[,ContData.env$myName.DateTime],format=ContData.env$myFormat.DateTime)
myT.diff.all <- difftime(myT[-1],myT[-length(myT)], units="mins")
myT.diff <- median(as.vector(myT.diff.all),na.rm=TRUE)
# convert DateTime to POSIX object (already done above)
#myT <- strptime(fun.data.import.mod[,myName.DateTime],format=myFormat.DateTime)
# A.2. Use data "as is"
# create zoo object of data and date/time (use row num instead)
zoo.data <- zoo::zoo(fun.data.import.mod[,fun.myField.Data],seq(from=1,to=nrow(fun.data.import.mod),by=1))  # works
#
# B. Rolling SD
# time difference is in minutes and Threshold is in hours
# "By" in rollapply goes by # of records not by a set time.
RollBy <- fun.myThresh.RoC.SD.period/(myT.diff[[1]]/60)
# right align says the previous 50
# +1 is to include the record itself
#RollSD <- rollapply(data=zoo.merge,width=RollBy+1,FUN=sd,na.rm=TRUE,fill=NA,align="right")
RollSD <- zoo::rollapply(data=zoo.data,width=RollBy+1,FUN=sd,na.rm=TRUE,fill=NA,align="right")
# add to data frame
fun.data.import.mod[,myField] <- RollSD
# clean up
rm(myT)
rm(zoo.data)
rm(RollSD)
#
# ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
#   #~~~~~~~~~~~~~
#   # slow but works (~10 seconds for 5k records)
#   # *******need to change to sapply***********
#   for (m in 1:nrow(fun.data.import.mod)) {
# #     print(m)
# #     flush.console()
#     fun.data.import.mod[m,myField] <- sd(fun.data.import.mod[,fun.myField.Data][
#         fun.data.import.mod[,myName.DateTime]<=fun.data.import.mod[m,myName.DateTime]
#         & fun.data.import.mod[,myName.DateTime]>=fun.data.import.mod[m,myField.T1]
#         ],na.rm=TRUE)
#   }
#   #
# A.3. Calc, NxSD, SD * n.per
myCalc.1 <- "SD"
myCalc.2 <- "SDxN"
myField.1 <- paste(fun.myField.Data,myCalc.1,sep=".")
myField.2 <- paste(fun.myField.Data,myCalc.2,sep=".")
fun.data.import.mod[,myField.2] <- fun.data.import.mod[,myField.1] * fun.myThresh.RoC.SD.number
#
# A.4. Calc, Diff (1:5) (5 is default but can be more)
for (i in 1:ContData.env$myThresh.Flat.MaxComp) {##FOR.i.START
myCalc <- paste("n",i,sep=".")
myField <- paste(fun.myField.Data,myCalc,sep=".")
fun.data.import.mod[-(1:i),myField] <- diff(as.numeric(fun.data.import.mod[,fun.myField.Data]),lag=i)
#
}##FOR.i.END
# only works as for loop, won't work as vector
#
#http://stackoverflow.com/questions/18862114/r-count-number-of-columns-by-a-condition-for-each-row
#
# A.5. Calc, flat.Hi, count n.1 etc if less than toler
myCalc <- "flat.Hi"
myField <- paste(fun.myField.Data,myCalc,sep=".")
myThresh <- fun.myThresh.Flat.Hi
# Fields to check
myFields.Match <- match(paste(fun.myField.Data,"n",1:myThresh,sep="."), names(fun.data.import.mod))
# use rowSums to count the fields
fun.data.import.mod[,myField] <- rowSums(abs(fun.data.import.mod[,myFields.Match])<=fun.myThresh.Flat.Tolerance)
#
# A.6. Calc, flat.Lo, count if less than toler
myCalc <- "flat.Lo"
myField <- paste(fun.myField.Data,myCalc,sep=".")
myThresh <- fun.myThresh.Flat.Lo
# Fields to check
myFields.Match <- match(paste(fun.myField.Data,"n",1:myThresh,sep="."), names(fun.data.import.mod))
# use rowSums to count the fields
fun.data.import.mod[,myField] <- rowSums(abs(fun.data.import.mod[,myFields.Match])<=fun.myThresh.Flat.Tolerance)
#
## B. Generate Flags based on Calculation Fields ####
# B.1. Gross
myQCTest <- "Gross"
myField <- paste("Flag",myQCTest,fun.myField.Data,sep=".")
# Assign Flags
# default value
fun.data.import.mod[,myField] <- ContData.env$myFlagVal.NotEval
# data is NA then flag = 9 (missing data)
fun.data.import.mod[,myField][is.na(fun.data.import.mod[,fun.myField.Data])==TRUE] <- ContData.env$myFlagVal.NoData
# different test for water level, only if negative
if(fun.myField.Data==ContData.env$myName.SensorDepth) {##IF.Gross.SensorDepth.START
# data < 0 (i.e., negative) = 4 (fail)
fun.data.import.mod[,myField][fun.data.import.mod[,fun.myField.Data] < 0] <- ContData.env$myFlagVal.Fail
# otherwise flag = 1 (pass)
fun.data.import.mod[,myField][fun.data.import.mod[,myField]==ContData.env$myFlagVal.NotEval] <- ContData.env$myFlagVal.Pass
# different test for discharge
} else if(fun.myField.Data==ContData.env$myName.Discharge) {
# data < 0 (i.e., negative) = 4 (fail)
fun.data.import.mod[,myField][fun.data.import.mod[,fun.myField.Data] < 0] <- ContData.env$myFlagVal.Fail
# otherwise flag = 1 (pass)
fun.data.import.mod[,myField][fun.data.import.mod[,myField]==ContData.env$myFlagVal.NotEval] <- ContData.env$myFlagVal.Pass
} else {
# data >= Suspect.Hi then flag = 3 (suspect)
fun.data.import.mod[,myField][fun.data.import.mod[,fun.myField.Data] >= fun.myThresh.Gross.Suspect.Hi] <- ContData.env$myFlagVal.Suspect
# data <= Suspect.Lo then flag = 3 (Suspect)
fun.data.import.mod[,myField][fun.data.import.mod[,fun.myField.Data] <= fun.myThresh.Gross.Suspect.Lo] <- ContData.env$myFlagVal.Suspect
# data >= Fail.Hi then flag = 4 (fail)
fun.data.import.mod[,myField][fun.data.import.mod[,fun.myField.Data] >= fun.myThresh.Gross.Fail.Hi] <- ContData.env$myFlagVal.Fail
# data <= Fail.Lo then flag = 4 (fail)
fun.data.import.mod[,myField][fun.data.import.mod[,fun.myField.Data] <= fun.myThresh.Gross.Fail.Lo] <- ContData.env$myFlagVal.Fail
# otherwise flag = 1 (pass)
fun.data.import.mod[,myField][fun.data.import.mod[,myField]==ContData.env$myFlagVal.NotEval] <- ContData.env$myFlagVal.Pass
}##IF.Gross.SensorDepth.END
# QC
#table(fun.data.import.mod[,myField])
#
# B.2. Spike
myQCTest <- "Spike"
myField <- paste("Flag",myQCTest,fun.myField.Data,sep=".")
myField.Calc.1 <- paste(fun.myField.Data,"n",1,sep=".")
# Assign Flags
# default value
fun.data.import.mod[,myField] <- ContData.env$myFlagVal.NotEval
# diff 1 is NA then flag = 9 (missing data)
fun.data.import.mod[,myField][is.na(fun.data.import.mod[,myField.Calc.1])==TRUE] <- ContData.env$myFlagVal.NoData
# abs(diff 1) >= spike Lo then flag = 3 (suspect)
fun.data.import.mod[,myField][abs(fun.data.import.mod[,myField.Calc.1]) >= fun.myThresh.Spike.Lo] <- ContData.env$myFlagVal.Suspect
# abs(diff 1) >= spike Hi then flag = 4 (fail)
fun.data.import.mod[,myField][abs(fun.data.import.mod[,myField.Calc.1]) >= fun.myThresh.Spike.Hi] <- ContData.env$myFlagVal.Fail
# otherwise flag = 1 (pass)
fun.data.import.mod[,myField][fun.data.import.mod[,myField]==ContData.env$myFlagVal.NotEval] <- ContData.env$myFlagVal.Pass
# QC
#table(fun.data.import.mod[,myField])
#
# B.3. RoC
myQCTest <- "RoC"
myField <- paste("Flag",myQCTest,fun.myField.Data,sep=".")
myField.Calc.1 <- paste(fun.myField.Data,"n",1,sep=".")
myField.Calc.2 <- paste(fun.myField.Data,"SDxN",sep=".")
# Assign Flags
# default value
fun.data.import.mod[,myField] <- ContData.env$myFlagVal.NotEval
# data is NA then flag = 9 (missing data)
fun.data.import.mod[,myField][is.na(fun.data.import.mod[,fun.myField.Data])==TRUE] <- ContData.env$myFlagVal.NoData
# sd is NA then flag = 9 (missing data)
fun.data.import.mod[,myField][is.na(fun.data.import.mod[,myField.Calc.1])==TRUE] <- ContData.env$myFlagVal.NoData
# diff 1 > SD*N then flag = 3 (suspect)
fun.data.import.mod[,myField][abs(fun.data.import.mod[,myField.Calc.1]) > fun.data.import.mod[,myField.Calc.2]] <- ContData.env$myFlagVal.Suspect
# otherwise flag = 1 (pass) [no 4/Fail]
fun.data.import.mod[,myField][fun.data.import.mod[,myField]==ContData.env$myFlagVal.NotEval] <- ContData.env$myFlagVal.Pass
# QC
#table(fun.data.import.mod[,myField])
#
# B.4. Flat
myQCTest <- "Flat"
myField <- paste("Flag",myQCTest,fun.myField.Data,sep=".")
myField.Calc.1 <- paste(fun.myField.Data,"flat.Hi",sep=".")
myField.Calc.2 <- paste(fun.myField.Data,"flat.Lo",sep=".")
# default value
fun.data.import.mod[,myField] <- ContData.env$myFlagVal.NotEval
# Lo >= Thresh.Lo = 3 (suspect)
fun.data.import.mod[,myField][fun.data.import.mod[,myField.Calc.2] >= fun.myThresh.Flat.Lo] <- ContData.env$myFlagVal.Suspect
# Hi >= Thresh.Hi = 4 (fail)
fun.data.import.mod[,myField][fun.data.import.mod[,myField.Calc.1] >= fun.myThresh.Flat.Hi] <- ContData.env$myFlagVal.Fail
# otherwise flag = 1 (pass)
fun.data.import.mod[,myField][fun.data.import.mod[,myField]==ContData.env$myFlagVal.NotEval] <- ContData.env$myFlagVal.Pass
# QC
#table(fun.data.import.mod[,myField])
#
#
# C. Assign Overall Data Flag ####
myField <- paste(ContData.env$myName.Flag,fun.myField.Data,sep=".")
#myNames.QCTests
# get column numbers (match) for QCTest Flags for this data
myFields.Match <- match(paste("Flag",ContData.env$myNames.QCTests,fun.myField.Data,sep="."), names(fun.data.import.mod))
# Conditional rowSums for number of flag fields with specified flags
myFlags.Num.Pass    <- rowSums(fun.data.import.mod[,myFields.Match]==ContData.env$myFlagVal.Pass)
myFlags.Num.Suspect <- rowSums(fun.data.import.mod[,myFields.Match]==ContData.env$myFlagVal.Suspect )
myFlags.Num.Fail    <- rowSums(fun.data.import.mod[,myFields.Match]==ContData.env$myFlagVal.Fail)
myFlags.Num.Missing <- rowSums(fun.data.import.mod[,myFields.Match]==ContData.env$myFlagVal.NoData)
myFlags.Num.OK      <- rowSums(fun.data.import.mod[,myFields.Match]==ContData.env$myFlagVal.Pass | fun.data.import.mod[,myFields.Match]==ContData.env$myFlagVal.NoData)
# Assign
# default value
fun.data.import.mod[,myField] <- ContData.env$myFlagVal.NotEval
# any QC Test flags = 3 then flag = 3 (suspect)
fun.data.import.mod[,myField][myFlags.Num.Suspect > 0] <- ContData.env$myFlagVal.Suspect
# any QC Test flags = 4 then flag = 4 (fail)
fun.data.import.mod[,myField][myFlags.Num.Fail > 0] <- ContData.env$myFlagVal.Fail
# all QC Test flags = 1 then flag = 1 (pass)
fun.data.import.mod[,myField][myFlags.Num.Pass == length(ContData.env$myNames.QCTests)] <- ContData.env$myFlagVal.Pass
# all QC Test flags = 1 or 9 then flag = 1 (pass)
fun.data.import.mod[,myField][myFlags.Num.OK == length(ContData.env$myNames.QCTests)] <- ContData.env$myFlagVal.Pass
#fun.data.import.mod[,myField][fun.data.import.mod[,myField]==myFlagVal.NotEval] <- myFlagVal.Pass
# data is NA then flag = 9 (missing data)
fun.data.import.mod[,myField][is.na(fun.data.import.mod[,fun.myField.Data])==TRUE] <- ContData.env$myFlagVal.NoData
# QC
#table(fun.data.import.mod[,myField])
#
# D. Clean Up ####
# D.1. Remove QC Calc fields
# #myNames.QCCalcs <- c("SD.Time","SD","SDxN","n.1","n.2","n.3","n.4","n.5","flat.Lo","flat.Hi")
# #ContData.env$myNames.QCCalcs <- c("SD.Time","SD","SDxN",paste("n",1:ContData.env$myThresh.Flat.MaxComp,sep="."),"flat.Lo","flat.Hi")
# # get field column numbers
# myFields.Match <- match(paste(fun.myField.Data,ContData.env$myNames.QCCalcs,sep="."), names(fun.data.import.mod))
# # drop fields from data table
# fun.data.import.mod <- fun.data.import.mod[,-na.omit(myFields.Match)]
# ~~~~~ Keep new "flag" fields (20170515)
# Flag Fields (myField is current Flag.Parameter)
FlagFields.Keep <- c(myField, paste(ContData.env$myName.Flag,ContData.env$myNames.QCTests,fun.myField.Data,sep="."))
myFields.Drop <- match(paste(fun.myField.Data,ContData.env$myNames.QCCalcs,sep="."), names(fun.data.import.mod))
fun.data.import.mod <- fun.data.import.mod[,-na.omit(myFields.Drop)]
#
# D.2. Offset Timing Fix
## Return a merged file if Offset is TRUE
if(boo.Offset==TRUE) {##IF.boo.Offset.START
# removed other data fields (and extra times) before above
# merge back
# all fields modified = ?????
#Fld.Mod <- c(ContData.env$myName.DateTime, fun.myField.Data)
# get fields added (20170512, add in Flag.Param)
Fld.Flag.Param <- match(myField, names(fun.data.import))
Fld.New <- names(fun.data.import.mod)[names(fun.data.import.mod) %in% names(fun.data.import)[-Fld.Flag.Param]==FALSE]
# merge on date time
DF.Return <- merge(fun.data.import[,-Fld.Flag.Param], fun.data.import.mod[,c(ContData.env$myName.DateTime, Fld.New)],
by=ContData.env$myName.DateTime, all.x=TRUE)
} else {
DF.Return <- fun.data.import.mod
}##IF.boo.Offset.END
#
#
# E. Function output ####
return(DF.Return)
#
}
myField <- ContData.env$myName.Discharge
if(myField %in% myNames.DataFields.Present==TRUE){##IF.myField.START
#
myMsg.data <- "Discharge"
myMsg <- paste("WORKING (QC Tests and Flags - ",myMsg.data,")",sep="")
myItems.Complete <- myItems.Complete + 1
myItems.Log[intCounter,2] <- myMsg
fun.Msg.Status(myMsg, intCounter, intItems.Total, strFile)
flush.console()
#
data.import <- fun.CalcQCStats(data.import
,myField
,ContData.env$myThresh.Gross.Fail.Hi.Discharge
,ContData.env$myThresh.Gross.Fail.Lo.Discharge
,ContData.env$myThresh.Gross.Suspect.Hi.Discharge
,ContData.env$myThresh.Gross.Suspect.Lo.Discharge
,ContData.env$myThresh.Spike.Hi.Discharge
,ContData.env$myThresh.Spike.Lo.Discharge
,ContData.env$myThresh.RoC.SD.period.Discharge
,ContData.env$myThresh.RoC.SD.number.Discharge
,ContData.env$myThresh.Flat.Hi.Discharge
,ContData.env$myThresh.Flat.Lo.Discharge
,ContData.env$myThresh.Flat.Tolerance.Discharge)
}##IF.myField.END
myField <- ContData.env$myName.GageHeight
myField
myMsg.data <- "GageHeight"
myMsg <- paste("WORKING (QC Tests and Flags - ",myMsg.data,")",sep="")
myItems.Complete <- myItems.Complete + 1
myItems.Log[intCounter,2] <- myMsg
fun.Msg.Status(myMsg, intCounter, intItems.Total, strFile)
flush.console()
# fun.CaclQCStats()
fun.data.import <- data.import
fun.myField.Data <- myField
fun.myThresh.Gross.Fail.Hi <- ContData.env$myThresh.Gross.Fail.Hi.GageHeight
fun.myThresh.Gross.Fail.Lo <- ContData.env$myThresh.Gross.Fail.Lo.GageHeight
fun.myThresh.Gross.Suspect.Hi <- ContData.env$myThresh.Gross.Suspect.Hi.GageHeight
fun.myThresh.Gross.Suspect.Lo <- ContData.env$myThresh.Gross.Suspect.Lo.GageHeight
fun.myThresh.Spike.Hi <- ContData.env$myThresh.Spike.Hi.GageHeight
fun.myThresh.Spike.Lo <- ContData.env$myThresh.Spike.Lo.GageHeight
fun.myThresh.RoC.SD.period <- ContData.env$myThresh.RoC.SD.period.GageHeight
fun.myThresh.RoC.SD.number <- fun.myThresh.RoC.SD.number
fun.myThresh.Flat.Hi <- ContData.env$myThresh.Flat.Hi.GageHeight
fun.myThresh.Flat.Lo <- ContData.env$myThresh.Flat.Lo.GageHeight
fun.myThresh.Flat.Tolerance <- ContData.env$myThresh.Flat.Tolerance.GageHeight
fun.data.import               <- data.import
fun.myField.Data              <- myField
fun.myThresh.Gross.Fail.Hi    <- ContData.env$myThresh.Gross.Fail.Hi.GageHeight
fun.myThresh.Gross.Fail.Lo    <- ContData.env$myThresh.Gross.Fail.Lo.GageHeight
fun.myThresh.Gross.Suspect.Hi <- ContData.env$myThresh.Gross.Suspect.Hi.GageHeight
fun.myThresh.Gross.Suspect.Lo <- ContData.env$myThresh.Gross.Suspect.Lo.GageHeight
fun.myThresh.Spike.Hi         <- ContData.env$myThresh.Spike.Hi.GageHeight
fun.myThresh.Spike.Lo         <- ContData.env$myThresh.Spike.Lo.GageHeight
fun.myThresh.RoC.SD.period    <- ContData.env$myThresh.RoC.SD.period.GageHeight
fun.myThresh.RoC.SD.number    <- ContData.env$myThresh.RoC.SD.number.GageHeight
fun.myThresh.Flat.Hi          <- ContData.env$myThresh.Flat.Hi.GageHeight
fun.myThresh.Flat.Lo          <- ContData.env$myThresh.Flat.Lo.GageHeight
fun.myThresh.Flat.Tolerance   <- ContData.env$myThresh.Flat.Tolerance.GageHeight
myNames.DataFields.Present.QCCalcs <- as.vector(t(outer(myNames.DataFields.Present,ContData.env$myNames.QCCalcs,paste,sep=".")))
myNames.Flags.QCTests <- paste("Flag.",as.vector(t(outer(ContData.env$myNames.QCTests,myNames.DataFields.Present,paste,sep="."))),sep="")
myNames.DataFields.Present.QCCalcs
myNames.DataFields.Present
myNames.DataFields.Present <- ContData.env$myNames.DataFields[ContData.env$myNames.DataFields %in% colnames(data.import)==TRUE]
myNames.DataFields.Present
myNames.DataFields2Mod <- c(ContData.env$myName.DateTime, myNames.DataFields.Present)
myNames.DataFields2Mod
# B.5.0. Add "RAW" and "Comment.MOD" fields
# default values
myName.Raw <- "RAW"
myName.Comment.Mod <- "Comment.MOD"
# 5.1. Cycle each present field
for (j in myNames.DataFields2Mod) {##FOR.j.START
#
# A. Add comment field and leave blank
data.import[,paste(myName.Comment.Mod,j,sep=".")] <- ""
# B. Add data.RAW and populate with original data
data.import[,paste(myName.Raw,j,sep=".")] <- data.import[,j]
#
}##FOR.j.END
#
#     # leave as a loop so get RAW and Comment together
#     j <- myNames.DataFields2Mod
#     # A. Add comment field and leave blank
#     data.import[,paste(myName.Comment.Mod,j,sep=".")] <- ""
#     # B. Add data.RAW and populate with original data
#     data.import[,paste(myName.Raw,j,sep=".")] <- data.import[,j]
#
File.Date.Start <- format(as.Date(strFile.Date.Start,ContData.env$myFormat.Date),"%Y%m%d")
File.Date.End   <- format(as.Date(strFile.Date.End,ContData.env$myFormat.Date),"%Y%m%d")
strFile.Out.Prefix <- "QC"
strFile.Out <- paste(paste(strFile.Out.Prefix,strFile.SiteID,strFile.DataType,File.Date.Start,File.Date.End,sep=ContData.env$myDelim),"csv",sep=".")
write.csv(data.import,file=paste(myDir.data.export,"/",strFile.Out,sep=""),quote=FALSE,row.names=FALSE)
fun.data.import               <- data.import
fun.myField.Data              <- myField
fun.myThresh.Gross.Fail.Hi    <- ContData.env$myThresh.Gross.Fail.Hi.GageHeight
fun.myThresh.Gross.Fail.Lo    <- ContData.env$myThresh.Gross.Fail.Lo.GageHeight
fun.myThresh.Gross.Suspect.Hi <- ContData.env$myThresh.Gross.Suspect.Hi.GageHeight
fun.myThresh.Gross.Suspect.Lo <- ContData.env$myThresh.Gross.Suspect.Lo.GageHeight
fun.myThresh.Spike.Hi         <- ContData.env$myThresh.Spike.Hi.GageHeight
fun.myThresh.Spike.Lo         <- ContData.env$myThresh.Spike.Lo.GageHeight
fun.myThresh.RoC.SD.period    <- ContData.env$myThresh.RoC.SD.period.GageHeight
fun.myThresh.RoC.SD.number    <- ContData.env$myThresh.RoC.SD.number.GageHeight
fun.myThresh.Flat.Hi          <- ContData.env$myThresh.Flat.Hi.GageHeight
fun.myThresh.Flat.Lo          <- ContData.env$myThresh.Flat.Lo.GageHeight
fun.myThresh.Flat.Tolerance   <- ContData.env$myThresh.Flat.Tolerance.GageHeight
fun.myField.Data.ALL <- names(fun.data.import)[names(fun.data.import) %in% ContData.env$myNames.DataFields]
boo.Offset <- fun.OffsetCollectionCheck(fun.data.import, fun.myField.Data.ALL, ContData.env$myName.DateTime)
if(boo.Offset==TRUE) {##IF.boo.Offset.START
# check time interval (na.omit removes all)
df.check <- na.omit(fun.data.import[,c(ContData.env$myName.DateTime,fun.myField.Data)])
# convert from Character to time if necessary (not necessary)
# if (is.character(df.check[,ContData.env$myName.DateTime])==TRUE){
#   myFormat  <- ContData.env$myFormat.DateTime #"%Y-%m-%d %H:%M:%S"
#   # df.check[,ContData.env$myName.DateTime] <- strftime(df.check[,ContData.env$myName.DateTime],
#   #                                                     format=myFormat,
#   #                                                     tz=ContData.env$myTZ)
# }
#x <- df.check[,ContData.env$myName.DateTime]
myT <- strptime(df.check[,ContData.env$myName.DateTime],format=ContData.env$myFormat.DateTime)
myTimeDiff.all <- difftime(myT[-1],myT[-length(myT)])
myTimeDiff <- median(as.vector(myTimeDiff.all),na.rm=TRUE)
# create time series
myTS <- seq(as.POSIXlt(min(myT),tz=ContData.env$myTZ),as.POSIXlt(max(myT),tz=ContData.env$myTZ),by="30 min") #by=paste0(myTimeDiff," min"))
length(myTS)
#~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
# remove other data fields (and extra times) before proceeding
### Fields to keep
myFlds.Keep <- c(ContData.env$myName.SiteID,
ContData.env$myName.DateTime, ContData.env$myName.Date, ContData.env$myName.Time,
ContData.env$myName.Mo, ContData.env$myName.Day, ContData.env$myName.Yr,
fun.myField.Data, paste0(ContData.env$myName.Flag,".",fun.myField.Data))
### Modify the DF
# keep only the relevant data field and remove all NA (case-wise)
fun.data.import.mod <- na.omit(fun.data.import[,myFlds.Keep])
#~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
# Check length.  If different add in extra times
## NA records would have been removed earlier
if (length(myTS) != nrow(df.check)){##IF.length.START
# add extra rows to new Time Series
ts.alltimes <- as.data.frame(as.character(myTS))
names(ts.alltimes) <- ContData.env$myName.DateTime
# merge (works with datetime as character but not as a POSIX field)
#df.check[,ContData.env$myName.DateTime] <- as.POSIXlt(df.check[,ContData.env$myName.DateTime],origin = "1900-01-01",tz=ContData.env$myTZ)
ts.alltimes.data <- merge(ts.alltimes, fun.data.import.mod, by=ContData.env$myName.DateTime)
# use new df moving forward
fun.data.import.mod <- ts.alltimes.data
}##IF.length.END
# then merge back at end
} else {
# rename fun.data.import (for non Offset)
fun.data.import.mod <- fun.data.import
}##IF.boo.Offset.END
myCalc <- "SD.Time"
myField <- paste(fun.myField.Data,myCalc,sep=".")
myT <- strptime(fun.data.import.mod[,ContData.env$myName.DateTime],format=ContData.env$myFormat.DateTime)
myT$hour <- myT$hour - fun.myThresh.RoC.SD.period
fun.data.import.mod[,myField] <- as.character(myT)
myField.T1 <- myField
myCalc <- "SD"
myField <- paste(fun.myField.Data,myCalc,sep=".")
if(nrow(fun.data.import.mod)<5) {##IF.nrow.START
myMsg <- paste("\n
The data file has less than 5 records.
The scripts will not work properly until you have more data."
,sep="")
stop(myMsg)
}##IF.1.END
myT.diff.all <- difftime(myT[-1],myT[-length(myT)], units="mins")
myT.diff <- median(as.vector(myT.diff.all),na.rm=TRUE)
zoo.data <- zoo::zoo(fun.data.import.mod[,fun.myField.Data],seq(from=1,to=nrow(fun.data.import.mod),by=1))  # works
RollBy <- fun.myThresh.RoC.SD.period/(myT.diff[[1]]/60)
RollSD <- zoo::rollapply(data=zoo.data,width=RollBy+1,FUN=sd,na.rm=TRUE,fill=NA,align="right")
fun.data.import.mod[,myField] <- RollSD
rm(myT)
rm(zoo.data)
rm(RollSD)
myCalc.1 <- "SD"
myCalc.2 <- "SDxN"
myField.1 <- paste(fun.myField.Data,myCalc.1,sep=".")
myField.2 <- paste(fun.myField.Data,myCalc.2,sep=".")
fun.data.import.mod[,myField.2] <- fun.data.import.mod[,myField.1] * fun.myThresh.RoC.SD.number
for (i in 1:ContData.env$myThresh.Flat.MaxComp) {##FOR.i.START
myCalc <- paste("n",i,sep=".")
myField <- paste(fun.myField.Data,myCalc,sep=".")
fun.data.import.mod[-(1:i),myField] <- diff(as.numeric(fun.data.import.mod[,fun.myField.Data]),lag=i)
#
}##FOR.i.END
myCalc <- "flat.Hi"
myField <- paste(fun.myField.Data,myCalc,sep=".")
myThresh <- fun.myThresh.Flat.Hi
myFields.Match <- match(paste(fun.myField.Data,"n",1:myThresh,sep="."), names(fun.data.import.mod))
fun.data.import.mod[,myField] <- rowSums(abs(fun.data.import.mod[,myFields.Match])<=fun.myThresh.Flat.Tolerance)
myCalc <- "flat.Hi"
myField <- paste(fun.myField.Data,myCalc,sep=".")
myThresh <- fun.myThresh.Flat.Hi
myFields.Match <- match(paste(fun.myField.Data,"n",1:myThresh,sep="."), names(fun.data.import.mod))
myThresh
fun.myThresh.Flat.Hi
#~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
# Library Name
myLibrary <- "ContDataQC" # "ContDataQC","MMIcalc","MMIcalcNV","MBSStools","XC95"
# Load Library
library(devtools)
#~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
# Create Package
# create(myLibrary)
#~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
# files to library folder
# file.copy("metric.values.R","./Library/MMIcalc/R/metric.values.R",overwrite=TRUE)
#~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
#
#~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
# Document, Install, and Reload Library
## Generate Documentation
setwd(paste0("./",myLibrary))
devtools::document()
## Install New Package (locally)
setwd("..") # return to root directory first
devtools::install(myLibrary)
## Reload library
library(myLibrary,character.only = TRUE)
# change wd back to package
setwd(paste0("./",myLibrary))
#~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
library(ContDataQC)
?ContDataQC
##~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
# Library Name
myLibrary <- "ContDataQC" # "ContDataQC","MMIcalc","MMIcalcNV","MBSStools","XC95"
# Load Library
library(devtools)
#~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
# Create Package
# create(myLibrary)
#~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
# files to library folder
# file.copy("metric.values.R","./Library/MMIcalc/R/metric.values.R",overwrite=TRUE)
#~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
#
#~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
# Document, Install, and Reload Library
## Generate Documentation
setwd(paste0("./",myLibrary))
devtools::document()
## Install New Package (locally)
setwd("..") # return to root directory first
devtools::install(myLibrary)
## Reload library
library(myLibrary,character.only = TRUE)
# change wd back to package
setwd(paste0("./",myLibrary))
#~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
