#
if(identical(split[, "DepthUnits"], character(0))==TRUE){##IF~identical~START
split[, "DepthNumber"] <- split[, "NonSiteID"]
split[, "DepthUnits"] <- NA
} else {
split[, "DepthNumber"] <- sub(split[, "DepthUnits"], "", split[, "NonSiteID"])
}##IF~identical~END
# Split ID String based on Delimiter into SiteID and NonSiteID
split <- data.frame(do.call("rbind", strsplit(as.character(df_import[, fun.ColName.ID]), myDelim.strsplit, fixed=TRUE)))
names(split) <- c("SiteID", "NonSiteID")
# Separate Units from NonSiteID
pat_units <- "[a-z]*$"  # characters, any number, at end of string
pat_matches <- regexpr(pat_units, split[, "NonSiteID"], perl=TRUE, ignore.case = TRUE)
split[, "DepthUnits"]  <- regmatches(split[, "NonSiteID"], pat_matches)
identical(split[, "DepthUnits"], character(0))==TRUE
head(split)
?sub
sub(split[, "DepthUnits"], "", split[, "NonSiteID"])
mean(1,6,21,26)
mean(c(1,6,21,26))
df_split$Erik <- apply(df_split, 1, FUN=sub(x[, "DepthUnits"], "", x[, "NonSiteID"]))
df_split$Erik <- apply(df_split[,c("DepthUnits", "NonSiteID")], 1, FUN=sub(x[, "DepthUnits"], "", x[, "NonSiteID"]))
apply(df_split[,c("DepthUnits", "NonSiteID")], 1, FUN=sub(x[, 1], "", x[, 2]))
apply(df_split[,c("DepthUnits", "NonSiteID")], 1, FUN=sub(x[1, 1], "", x[1, 2]))
apply(df_split[,c("DepthUnits", "NonSiteID")], 2, FUN=sub(x[, 1], "", x[, 2]))
lapply(df_split[,c("DepthUnits", "NonSiteID")], function(x){sub(x[,1], "", x[,2])})
# Keep original ID String
df_import[,"ID_Full"] <- df_import[, fun.ColName.ID]
# Split ID String based on Delimiter into SiteID and NonSiteID
df_split <- data.frame(do.call("rbind", strsplit(as.character(df_import[, fun.ColName.ID]), myDelim.strsplit, fixed=TRUE)))
names(df_split) <- c("SiteID", "NonSiteID")
# Separate Units from NonSiteID
pat_units <- "[a-z]*$"  # characters, any number, at end of string
pat_matches <- regexpr(pat_units, df_split[, "NonSiteID"], perl=TRUE, ignore.case = TRUE)
df_split[, "DepthUnits"]  <- regmatches(df_split[, "NonSiteID"], pat_matches)
df_split[,c("DepthUnits", "NonSiteID")]
head(df_split[,c("DepthUnits", "NonSiteID")])
lapply(df_split[,c("DepthUnits", "NonSiteID")], function(x){sub(x[,1], "", x[,2])})
sapply(df_split[,c("DepthUnits", "NonSiteID")], function(x){sub(x[,1], "", x[,2])})
sapply(df_split[,c("DepthUnits", "NonSiteID")], function(x) sub(x[,1], "", x[,2]))
?lapply
lapply(df_split[,c("DepthUnits", "NonSiteID")], 2, FUN=sub(x[, 1], "", x[, 2]))
?transform
x <- transform(df_split, New = sub(DepthUnits, "", NonSiteID))
x
?sub
for(i in nrow(df_split)){
df_split[i, "new"] <- sub(df_import[, "DepthUnits"], "", df_import[i, "NonSiteID"])
}
names(df_split)
for(i in nrow(df_split)){
df_split[i, "new"] <- sub(df_split[, "DepthUnits"], "", df_split[i, "NonSiteID"])
}
for(i in nrow(df_split)){
df_split[i, "new"] <- sub(df_split[i, "DepthUnits"], "", df_split[i, "NonSiteID"])
}
head(df_split)
tail(df_split)
#
for(i in nrow(df_split)){##FOR~i~START
if(identical(df_split[i, "DepthUnits"], character(0))==TRUE){##IF~identical~START
df_split[i, "DepthNumber"] <- df_split[i, "NonSiteID"]
df_split[i, "DepthUnits"]  <- NA
} else {
df_split[i, "DepthNumber"] <- sub(df_split[i, "DepthUnits"], "", df_split[i, "NonSiteID"])
# df_split$Erik <- lapply(df_split[,c("DepthUnits", "NonSiteID")], 2, FUN=sub(x[, 1], "", x[, 2]))
}##IF~identical~END
}##FOR~i~END
head(df_split)
tail(df_split)
i <- 1
nrow(df_split)
for(i in 1:nrow(df_split)){##FOR~i~START
if(identical(df_split[i, "DepthUnits"], character(0))==TRUE){##IF~identical~START
df_split[i, "DepthNumber"] <- df_split[i, "NonSiteID"]
df_split[i, "DepthUnits"]  <- NA
} else {
df_split[i, "DepthNumber"] <- sub(df_split[i, "DepthUnits"], "", df_split[i, "NonSiteID"])
# df_split$Erik <- lapply(df_split[,c("DepthUnits", "NonSiteID")], 2, FUN=sub(x[, 1], "", x[, 2]))
}##IF~identical~END
}##FOR~i~END
head(df_split)
tail(df_split)
# Keep original ID String
df_import[,"ID_Full"] <- df_import[, fun.ColName.ID]
# Split ID String based on Delimiter into SiteID and NonSiteID
df_split <- data.frame(do.call("rbind", strsplit(as.character(df_import[, fun.ColName.ID]), myDelim.strsplit, fixed=TRUE)))
names(df_split) <- c("SiteID", "NonSiteID")
# Separate Units from NonSiteID
pat_units <- "[a-z]*$"  # characters, any number, at end of string
pat_matches <- regexpr(pat_units, df_split[, "NonSiteID"], perl=TRUE, ignore.case = TRUE)
df_split[, "DepthUnits"]  <- regmatches(df_split[, "NonSiteID"], pat_matches)
#
for(i in 1:nrow(df_split)){##FOR~i~START
if(identical(df_split[i, "DepthUnits"], character(0))==TRUE){##IF~identical~START
df_split[i, "DepthNumber"] <- df_split[i, "NonSiteID"]
df_split[i, "DepthUnits"]  <- NA
} else {
df_split[i, "DepthNumber"] <- sub(df_split[i, "DepthUnits"], "", df_split[i, "NonSiteID"])
# df_split$Erik <- lapply(df_split[,c("DepthUnits", "NonSiteID")], 2, FUN=sub(x[, 1], "", x[, 2]))
}##IF~identical~END
}##FOR~i~END
head(df_split)
tail(df_split)
dim(df_import)
dim(df_split)
#
#' @export
fun.ParseID <- function(fun.myFileName.In
, fun.myFileName.Out
, fun.ColName.ID
, fun.Delim=NA) {##FUNCTION~fun.ParseID~START
# DEBUG
boo_DEBUG <- FALSE
# Loop through each file
for (i in fun.myFileName.In){##IF~i~START
#
# DEBUG
if(boo_DEBUG==TRUE){##IF~boo_DEBUG~START
i <- fun.myFileName.In[1]
}##IF~boo_DEBUG~END
#
i_num <- match(i, fun.myFileName.In)
i_len <- length(fun.myFileName.In)
# QC
if(file.exists(i)==FALSE){##IF~file.exists~START
msg <- paste0("Specified file does not exist; ", i)
stop(msg)
}##IF~file.exists~END
# Import
df_import <- read.csv(i)
# ID String
str_ID <- as.character(unique(df_import[, fun.ColName.ID]))
# Delimiter
if(is.na(fun.Delim)==TRUE){##IF~is.na~START
myDelim.strsplit <- ContData.env$myDelim_LakeID
} else {
myDelim.strsplit <- fun.Delim
}##IF~is.na~END
# Keep original ID String
df_import[,"ID_Full"] <- df_import[, fun.ColName.ID]
# Split ID String based on Delimiter into SiteID and NonSiteID
df_split <- data.frame(do.call("rbind", strsplit(as.character(df_import[, fun.ColName.ID]), myDelim.strsplit, fixed=TRUE)))
names(df_split) <- c("SiteID", "NonSiteID")
# Separate Units from NonSiteID
pat_units <- "[a-z]*$"  # characters, any number, at end of string
pat_matches <- regexpr(pat_units, df_split[, "NonSiteID"], perl=TRUE, ignore.case = TRUE)
df_split[, "DepthUnits"]  <- regmatches(df_split[, "NonSiteID"], pat_matches)
#
for(i in 1:nrow(df_split)){##FOR~i~START
if(identical(df_split[i, "DepthUnits"], character(0))==TRUE){##IF~identical~START
df_split[i, "DepthNumber"] <- df_split[i, "NonSiteID"]
df_split[i, "DepthUnits"]  <- NA
} else {
df_split[i, "DepthNumber"] <- sub(df_split[i, "DepthUnits"], "", df_split[i, "NonSiteID"])
# df_split$Erik <- lapply(df_split[,c("DepthUnits", "NonSiteID")], 2, FUN=sub(x[, 1], "", x[, 2]))
}##IF~identical~END
}##FOR~i~END
# Add columns
df_import[, "ID_Full"]       <- df_import[, fun.ColName.ID]
df_import[, "ID_Depth" ]     <- df_split[, "DepthNumber"]
df_import[, "ID_DepthUnits"] <- df_split[, "DepthUnits"]
df_import[, fun.ColName.ID]  <- df_split[, "SiteID"]
# Export the file
write.csv(df_import, fun.myFileName.Out[i_num])
}##IF~i~END
print(paste0("Task COMPLETE; ", i_len, " items."))
flush.console()
}
?fun.parseID
getwd()
fun.myFileName.In
fun.myFileName.Out
fun.ParseID(fun.myFileName.In
, fun.myFileName.Out
, fun.ColName.ID
, fun.Delim)
df_Ellis <- read.csv(file.path(system.file("extdata", package="ContDataQC"), "Ellis.csv"))
df_Ellis[, "Date.Time"] <- as.POSIXct(df_Ellis[, "Date.Time"])
p <- ggplot(df_Ellis, aes(x=Date.Time, y=Water.Temp.C, group=ID_Depth)) +
geom_point(aes(color=ID_Depth)) +
scale_color_continuous(trans="reverse") +
scale_x_datetime(date_labels = "%Y-%m")
#'
p
?ContDataQC
head(df_split
)
# NEWS
# Render then Copy NEWS so picked up in help
rmarkdown::render("NEWS.rmd", "all")
file.copy("NEWS.md", "NEWS", overwrite = TRUE)
file.remove("NEWS.html")
file.remove("NEWS.md")
#
# Library Name
myLibrary <- "ContDataQC"
# Load Library
library(devtools)
#~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
# Create Package
# create(myLibrary)
#~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
#
#~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
# Document, Install, and Reload Library
## Generate Documentation
setwd(paste0("./",myLibrary))
devtools::document()
## Install New Package (locally)
setwd("..") # return to root directory first
devtools::install(myLibrary)
## Reload library
library(myLibrary,character.only = TRUE)
# change wd back to package
setwd(paste0("./",myLibrary))
setwd("C:/Users/Erik.Leppo/OneDrive - Tetra Tech, Inc/MyDocs_OneDrive/GitHub/ContDataQC")
# NEWS
# Render then Copy NEWS so picked up in help
rmarkdown::render("NEWS.rmd", "all")
file.copy("NEWS.md", "NEWS", overwrite = TRUE)
file.remove("NEWS.html")
file.remove("NEWS.md")
#
# Library Name
myLibrary <- "ContDataQC"
# Load Library
library(devtools)
#~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
# Create Package
# create(myLibrary)
#~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
#
#~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
# Document, Install, and Reload Library
## Generate Documentation
setwd(paste0("./",myLibrary))
devtools::document()
## Install New Package (locally)
setwd("..") # return to root directory first
devtools::install(myLibrary)
## Reload library
library(myLibrary,character.only = TRUE)
# change wd back to package
setwd(paste0("./",myLibrary))
pkg <- "ContDataQC"
library(pkg, character.only = TRUE)
help(package=(pkg))
#
# Parse ID string and save
dir_files <- file.path("./Data3_Aggregated")
setwd(dir_files)
fun.myFileName.In <- "DATA_QC_Ellis~1.0m_Water_20180524_20180918_Append_2.csv"
fun.myFileName.Out <- "Ellis_FixedID.csv"
fun.ColName.ID <- "SiteID"
fun.Delim <- "~"
fun.ParseID(fun.myFileName.In
, fun.myFileName.Out
, fun.ColName.ID
, fun.Delim)
# Example code to Plot data
library(ggplot2)
# Read file
df_Ellis <- read.csv(file.path(system.file("extdata", package="ContDataQC"), "Ellis.csv"))
df_Ellis[, "Date.Time"] <- as.POSIXct(df_Ellis[, "Date.Time"])
# Plot, Create
p <- ggplot(df_Ellis, aes(x=Date.Time, y=Water.Temp.C, group=ID_Depth)) +
geom_point(aes(color=ID_Depth)) +
scale_color_continuous(trans="reverse") +
scale_x_datetime(date_labels = "%Y-%m")
# Plot, Show
print(p)
# NEWS
# Render then Copy NEWS so picked up in help
rmarkdown::render("NEWS.rmd", "all")
file.copy("NEWS.md", "NEWS", overwrite = TRUE)
file.remove("NEWS.html")
file.remove("NEWS.md")
#
# Library Name
myLibrary <- "ContDataQC"
# Load Library
library(devtools)
#~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
# Create Package
# create(myLibrary)
#~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
#
#~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
# Document, Install, and Reload Library
## Generate Documentation
setwd(paste0("./",myLibrary))
devtools::document()
## Install New Package (locally)
setwd("..") # return to root directory first
devtools::install(myLibrary)
## Reload library
library(myLibrary,character.only = TRUE)
# change wd back to package
setwd(paste0("./",myLibrary))
setwd("C:/Users/Erik.Leppo/OneDrive - Tetra Tech, Inc/MyDocs_OneDrive/GitHub/ContDataQC")
# NEWS
# Render then Copy NEWS so picked up in help
rmarkdown::render("NEWS.rmd", "all")
file.copy("NEWS.md", "NEWS", overwrite = TRUE)
file.remove("NEWS.html")
file.remove("NEWS.md")
#
# Library Name
myLibrary <- "ContDataQC"
# Load Library
library(devtools)
#~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
# Create Package
# create(myLibrary)
#~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
#
#~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
# Document, Install, and Reload Library
## Generate Documentation
setwd(paste0("./",myLibrary))
devtools::document()
## Install New Package (locally)
setwd("..") # return to root directory first
devtools::install(myLibrary)
## Reload library
library(myLibrary,character.only = TRUE)
# change wd back to package
setwd(paste0("./",myLibrary))
pkg <- "ContDataQC"
library(pkg, character.only = TRUE)
help(package=(pkg))
# Example code to Plot data
library(ggplot2)
# Read file
df_Ellis <- read.csv(file.path(system.file("extdata", package="ContDataQC"), "Ellis.csv"))
df_Ellis[, "Date.Time"] <- as.POSIXct(df_Ellis[, "Date.Time"])
# Plot, Create
p <- ggplot(df_Ellis, aes(x=Date.Time, y=Water.Temp.C, group=ID_Depth)) +
geom_point(aes(color=ID_Depth)) +
scale_color_continuous(trans="reverse") +
scale_x_datetime(date_labels = "%Y-%m")
# Plot, Show
print(p)
# NEWS
# Render then Copy NEWS so picked up in help
rmarkdown::render("NEWS.rmd", "all")
file.copy("NEWS.md", "NEWS", overwrite = TRUE)
file.remove("NEWS.html")
file.remove("NEWS.md")
#
# Library Name
myLibrary <- "ContDataQC"
# Load Library
library(devtools)
#~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
# Create Package
# create(myLibrary)
#~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
#
#~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
# Document, Install, and Reload Library
## Generate Documentation
setwd(paste0("./",myLibrary))
devtools::document()
## Install New Package (locally)
setwd("..") # return to root directory first
devtools::install(myLibrary)
## Reload library
library(myLibrary,character.only = TRUE)
# change wd back to package
setwd(paste0("./",myLibrary))
pkg <- "ContDataQC"
library(pkg, character.only = TRUE)
help(package=(pkg))
# generate Vignette
library(ContDataQC)
library(devtools)
devtools::build_vignettes()
# NEWS
# Render then Copy NEWS so picked up in help
rmarkdown::render("NEWS.rmd", "all")
file.copy("NEWS.md", "NEWS", overwrite = TRUE)
file.remove("NEWS.html")
file.remove("NEWS.md")
#
# Library Name
myLibrary <- "ContDataQC"
# Load Library
library(devtools)
#~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
# Create Package
# create(myLibrary)
#~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
#
#~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
# Document, Install, and Reload Library
## Generate Documentation
setwd(paste0("./",myLibrary))
devtools::document()
## Install New Package (locally)
setwd("..") # return to root directory first
devtools::install(myLibrary)
## Reload library
library(myLibrary,character.only = TRUE)
# change wd back to package
setwd(paste0("./",myLibrary))
pkg <- "ContDataQC"
library(pkg, character.only = TRUE)
help(package=(pkg))
# NEWS
# Render then Copy NEWS so picked up in help
rmarkdown::render("NEWS.rmd", "all")
file.copy("NEWS.md", "NEWS", overwrite = TRUE)
file.remove("NEWS.html")
file.remove("NEWS.md")
#
# Library Name
myLibrary <- "ContDataQC"
# Load Library
library(devtools)
#~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
# Create Package
# create(myLibrary)
#~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
#
#~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
# Document, Install, and Reload Library
## Generate Documentation
setwd(paste0("./",myLibrary))
devtools::document()
## Install New Package (locally)
setwd("..") # return to root directory first
devtools::install(myLibrary)
## Reload library
library(myLibrary,character.only = TRUE)
# change wd back to package
setwd(paste0("./",myLibrary))
pkg <- "ContDataQC"
library(pkg, character.only = TRUE)
help(package=(pkg))
pkg <- "ContDataQC"
library(pkg, character.only = TRUE)
help(package=(pkg))
getwd()
# generate Vignette
library(ContDataQC)
library(devtools)
devtools::build_vignettes()
# NEWS
# Render then Copy NEWS so picked up in help
rmarkdown::render("NEWS.rmd", "all")
file.copy("NEWS.md", "NEWS", overwrite = TRUE)
file.remove("NEWS.html")
file.remove("NEWS.md")
#
# Library Name
myLibrary <- "ContDataQC"
# Load Library
library(devtools)
#~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
# Create Package
# create(myLibrary)
#~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
dir_base <- "C:/Users/Erik.Leppo/OneDrive - Tetra Tech, Inc/MyDocs_OneDrive/GitHub/"
#~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
# Document, Install, and Reload Library
## Generate Documentation
setwd(file.path(dir_base, myLibrary))
devtools::document()
## Install New Package (locally)
setwd("..") # return to root directory first
devtools::install(myLibrary)
## Reload library
library(myLibrary,character.only = TRUE)
# change wd back to package
setwd(file.path(dir_base, myLibrary))
pkg <- "ContDataQC"
library(pkg, character.only = TRUE)
help(package=(pkg))
# NEWS
# Render then Copy NEWS so picked up in help
rmarkdown::render("NEWS.rmd", "all")
file.copy("NEWS.md", "NEWS", overwrite = TRUE)
file.remove("NEWS.html")
file.remove("NEWS.md")
#
# Library Name
myLibrary <- "ContDataQC"
# Load Library
library(devtools)
#~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
# Create Package
# create(myLibrary)
#~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
dir_base <- "C:/Users/Erik.Leppo/OneDrive - Tetra Tech, Inc/MyDocs_OneDrive/GitHub/"
#~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
# Document, Install, and Reload Library
## Generate Documentation
setwd(file.path(dir_base, myLibrary))
devtools::document()
## Install New Package (locally)
setwd("..") # return to root directory first
devtools::install(myLibrary)
## Reload library
library(myLibrary,character.only = TRUE)
# change wd back to package
setwd(file.path(dir_base, myLibrary))
pkg <- "ContDataQC"
library(pkg, character.only = TRUE)
help(package=(pkg))
#
