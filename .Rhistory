# ContData.env$myFlagVal.Fail    <- "F"
# ContData.env$myName.Flag        <- "Flag" # flag prefix
# ContData.env$myName.Flag.WaterTemp  <- paste(ContData.env$myName.Flag,ContData.env$myName.WaterTemp,sep=".")
# #Trigger for Stats to exclude (TRUE) or include (FALSE) where flag = "fail"
# ContData.env$myStats.Fails.Exclude <- TRUE
#
# QC.1. Define parameter flag field
## If flag parameter names is different from config then it won't be found
myParam.Name.Flag <- paste(ContData.env$myName.Flag, i, sep=".")
# QC.2. Modify columns to keep (see 3.2.) based on presence of "flag" field
## give user feedback
if (myParam.Name.Flag %in% names(df.load)) {##IF.flagINnames.START
# QC.2.1. Flag field present in data
myCol <- c(fun.myDateTime.Name, i, myParam.Name.Flag)
# QC.2.1.1. Convert "Fails" to NA where appropriate
if (ContData.env$myStats.Fails.Exclude == TRUE) {##IF.Fails.START
# find Fails
myFails <- df.load[,myParam.Name.Flag]==ContData.env$myFlagVal.Fail
myFails.Num <- sum(myFails)
# convert to NA
df.load[myFails, i] <- NA
# Message to User
myMsg <- paste0("QC Flag field was found and ", myFails.Num, " fails were excluded based on user's config file.")
} else {
# Message to User
myMsg <- "QC Flag field was found and fails were all included based on user's config file."
}##IF.Fails.END
#
} else {
# QC.2.2. No Flag column
myCol <- c(fun.myDateTime.Name, i)
myMsg <- "No QC Flag field was found so all data points were used in calculations."
}##IF.flagINnames.END
cat(paste0(myMsg, "\n"))
# 3. Munge Data####
# 3.1. Subset Fields
df.param <- df.load[,myCol]
# 3.2. Add "Date" field
myDate.Name <- "Date"
df.param[,myDate.Name] <- as.Date(df.param[,fun.myDateTime.Name], fd01)
# 3.3. Data column to numeric
# may get "NAs introduced by coercion" so suppress
df.param[,i] <- suppressWarnings(as.numeric(df.param[,i]))
#~~~~~~~~~~~~~~~~~~~~~~~~~
# OLD method using doBy
# 4. Daily Stats for data####
# Calculate daily mean, max, min, range, sd, n
# 4.1. Define FUNCTION for use with summaryBy
myQ <- c(0.01,0.05,0.10,0.25,0.50,0.75,0.90,0.95,0.99)
myFUN.Names <- c("mean","median","min","max","range","sd","var","cv","n",paste("q",formatC(100*myQ,width=2,flag="0"),sep=""))
#
myFUN.sumBy <- function(x, ...){##FUN.myFUN.sumBy.START
c(mean=mean(x,na.rm=TRUE)
,median=median(x,na.rm=TRUE)
,min=min(x,na.rm=TRUE)
,max=max(x,na.rm=TRUE)
,range=max(x,na.rm=TRUE)-min(x,na.rm=TRUE)
,sd=sd(x,na.rm=TRUE)
,var=var(x,na.rm=TRUE)
,cv=sd(x,na.rm=TRUE)/mean(x,na.rm=TRUE)
,n=length(x)
,q=quantile(x,probs=myQ,na.rm=TRUE)
)
}##FUN.myFUN.sumBy.END
# 4.2.  Rename data column (summaryBy doesn't like variables)
names(df.param)[match(i,names(df.param))] <- "x"
# 4.2. Summary
df.summary <- doBy::summaryBy(x ~ Date, data=df.param, FUN=myFUN.sumBy, na.rm=TRUE
, var.names=i)
# 20181115, Save df.summary for report
if(i.num==1){##FOR.i.num.START
df.summary.plot.1 <- df.summary
} else if (i.num==2){
df.summary.plot.2 <- df.summary
}
#~~~~~~~~~~~~~~~~~~~~~~~~~
# # 4. Daily stats
# # dplyr summary (not working with variable name)
# x <- quo(fun.myParam.Name)
# df.summary <- df.param %>%
#                 dplyr::group_by(Date) %>%
#                   dplyr::summarise(n=n()
#                                    #,min=min(fun.myParam.Name,na.rm=TRUE)
#                                     ,mean=mean(!!x,na.rm=TRUE)
#                                    # ,max=mean(fun.myParam.Name,na.rm=TRUE)
#                                    # ,sd=sd(fun.myParam.Name,na.rm=TRUE)
#                                    )
# 5. Determine period start date####
# Loop through each Period (N and Units)
numPeriods <- length(fun.myPeriod.N)
myDate.Start <- rep(myDate.End, numPeriods)
for (k in 1:numPeriods) {##FOR.k.START
if(tolower(fun.myPeriod.Units[k])=="d" ) {##IF.format.START
# day, $mday
myDate.Start[k]$mday <- myDate.End$mday - (fun.myPeriod.N[k] - 1)
} else if(tolower(fun.myPeriod.Units[k])=="y") {
# year, $year
myDate.Start[k]$year <- myDate.End$year - fun.myPeriod.N[k]
myDate.Start[k]$mday <- myDate.End$mday + 1
} else {
myMsg <- paste0("Provided period units (",fun.myPeriod.Units
,") unrecognized.  Accepted values are 'd', 'm', or 'y').")
stop(myMsg)
}##IF.format.END
}##FOR.k.END
# 20181114, change from i to k
#~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
# # single period
# myDate.Start <- myDate.End
# if(tolower(fun.myPeriod.Units)=="d" ) {##IF.format.START
#   # day, $mday
#   myDate.Start$mday <- myDate.End$mday - (fun.myPeriod.N - 1)
# } else if(tolower(fun.myPeriod.Units)=="y") {
#   # year, $year
#   myDate.Start$year <- myDate.End$year - fun.myPeriod.N
#   myDate.Start$mday <- myDate.End$mday + 1
# } else {
#   myMsg <- paste0("Provided period units (",fun.myPeriod.Units
#                   ,") unrecognized.  Accepted values are 'd', 'm', or 'y').")
#   stop(myMsg)
# }##IF.format.END
#~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
# # 6.0. Subset Date Range
# df.subset <- df.subset[df.subset[,myDate.Name]>=myDate.Start & df.subset[,myDate.Name]<=myDate.End,]
# # df.period <- df.summary %>%
# #               dplyr::filter(myDate.Name>=myDate.Start, myDate.Name<=myDate.End)
#~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
# 6. Subset and Save summary file ####
myDate <- format(Sys.Date(),"%Y%m%d")
myTime <- format(Sys.time(),"%H%M%S")
myFile.Export.ext <- ".csv"
myFile.Export.base <- substr(fun.myFile,1,nchar(fun.myFile)-4)
# Loop through sets
# numPeriods defined above
for (j in 1:numPeriods){##FOR.j.START
# subset
df.summary.subset <- df.summary[df.summary[,myDate.Name]>=as.Date(myDate.Start[j]) & df.summary[,myDate.Name]<=as.Date(myDate.End),]
# create file name
myFile.Export.full <- paste0(paste(myFile.Export.base
,"PeriodStats"
,fun.myDate
,i
,paste0(fun.myPeriod.N[j],fun.myPeriod.Units[j])
,myDate
,myTime
,sep="_")
,myFile.Export.ext)
# save
write.csv(df.summary.subset, file.path(fun.myDir.export, myFile.Export.full),quote=FALSE,row.names=FALSE)
}##FOR.j.END
#
}##FOR.i.END
# 7. Generate markdown summary file with plots ####
# extra info for report (20180118)
myDate.File.Min <- min(df.load$Date)
myDate.Diff.FileMin.Benchmark <- as.Date(fun.myDate) - as.Date(myDate.File.Min)
# Error Check, Report Format
if(fun.myReport.format==""){
fun.myReport.format <- ContData.env$myReport.Format
}
fun.myReport.format <- tolower(fun.myReport.format)
# 20180212
# Error Check, Report Directory
if(fun.myReport.Dir==""){
fun.myReport.Dir <- ContData.env$myReport.Dir
}
#myReport.Name <- paste0("Report_PeriodStats","_",fun.myReport.format)
myReport.Name <- "Report_PeriodStats"
myPkg <- "ContDataQC"
if(boo.DEBUG==1){
strFile.RMD <- file.path(getwd(),"inst","rmd",paste0(myReport.Name,".rmd")) # for testing
} else {
#strFile.RMD <- system.file(paste0("rmd/",myReport.Name,".rmd"),package=myPkg)
# use provided dir for template
strFile.RMD <- file.path(fun.myReport.Dir, paste0(myReport.Name, ".rmd"))
}
#
#
strFile.out.ext <- paste0(".",fun.myReport.format) #".docx" # ".html"
strFile.out <- paste0(paste(myFile.Export.base,"PeriodStats",fun.myDate,paste(fun.myParam.Name,collapse="_"),myDate,myTime,sep="_"), strFile.out.ext)
strFile.RMD.format <- paste0(ifelse(fun.myReport.format=="docx","word",fun.myReport.format),"_document")
#
rmarkdown::render(strFile.RMD, output_format=strFile.RMD.format
,output_file=strFile.out, output_dir=fun.myDir.export
, quiet=TRUE)
rmarkdown::render(strFile.RMD, output_format=strFile.RMD.format
,output_file=strFile.out, output_dir=fun.myDir.export
, quiet=TRUE)
# Library Name
myLibrary <- "ContDataQC"
# Load Library
library(devtools)
#~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
# Create Package
# create(myLibrary)
#~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
#
#~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
# Document, Install, and Reload Library
## Generate Documentation
setwd(paste0("./",myLibrary))
devtools::document()
## Install New Package (locally)
setwd("..") # return to root directory first
devtools::install(myLibrary)
## Reload library
library(myLibrary,character.only = TRUE)
# change wd back to package
setwd(paste0("./",myLibrary))
library(ContDataQC)
help(package="ContDataQC")
#~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
# Save example files from Package to use for example
## This step not needed for users working on their own files
df.x <- DATA_period_test2_Aw_20130101_20141231
write.csv(df.x,"DATA_period_test2_Aw_20130101_20141231.csv")
myFile <- "config.ExcludeFailsFalse.R"
file.copy(file.path(path.package("ContDataQC"), "extdata", myFile)
, file.path(getwd(), myFile))
#~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
# Load File to use for PeriodStats
myDir <- getwd()
myFile <- "DATA_period_test2_Aw_20130101_20141231.csv"
df.x <- read.csv(file.path(myDir, myFile))
# function inputs
myDate <- "2013-09-30"
myDate.Format <- "%Y-%m-%d"
myPeriod.N <- c(30, 60, 90, 120, 1)
myPeriod.Units <- c("d", "d", "d", "d", "y")
myFile <- "DATA_period_test2_Aw_20130101_20141231.csv"
myDir.import <- getwd()
myDir.export <- getwd()
myParam.Name <- "Water.Temp.C"
myDateTime.Name <- "Date.Time"
myDateTime.Format <- "%Y-%m-%d %H:%M:%S"
myThreshold <- 20
myConfig <- ""
myReport.format <- "docx"
# Custom Config
myConfig.Fail.Include  <- "config.ExcludeFailsFalse.R"
# Run Function
## Example 1. default report format (html)
PeriodStats(myDate
, myDate.Format
, myPeriod.N
, myPeriod.Units
, myFile
, myDir.import
, myDir.export
, myParam.Name
, myDateTime.Name
, myDateTime.Format
, myThreshold
, myConfig)
## Example 2. DOCX report format
PeriodStats(myDate
, myDate.Format
, myPeriod.N
, myPeriod.Units
, myFile
, myDir.import
, myDir.export
, myParam.Name
, myDateTime.Name
, myDateTime.Format
, myThreshold
, myConfig
, myReport.format)
## Example 3. DOCX report format and Include Flag Failures
PeriodStats(myDate
, myDate.Format
, myPeriod.N
, myPeriod.Units
, myFile
, myDir.import
, myDir.export
, myParam.Name
, myDateTime.Name
, myDateTime.Format
, myThreshold
, myConfig.Fail.Include
, myReport.format)
## Example 4. DOCX report format with two parameters
myParam.Name <- c("Water.Temp.C", "Sensor.Depth.ft")
PeriodStats(myDate
, myDate.Format
, myPeriod.N
, myPeriod.Units
, myFile
, myDir.import
, myDir.export
, myParam.Name
, myDateTime.Name
, myDateTime.Format
, myThreshold
, myConfig
, myReport.format)
myReport.format <- "html"
PeriodStats(myDate
, myDate.Format
, myPeriod.N
, myPeriod.Units
, myFile
, myDir.import
, myDir.export
, myParam.Name
, myDateTime.Name
, myDateTime.Format
, myThreshold
, myConfig
, myReport.format)
# Library Name
myLibrary <- "ContDataQC"
# Load Library
library(devtools)
#~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
# Create Package
# create(myLibrary)
#~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
#
#~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
# Document, Install, and Reload Library
## Generate Documentation
setwd(paste0("./",myLibrary))
devtools::document()
## Install New Package (locally)
setwd("..") # return to root directory first
devtools::install(myLibrary)
## Reload library
library(myLibrary,character.only = TRUE)
# change wd back to package
setwd(paste0("./",myLibrary))
# Library Name
myLibrary <- "ContDataQC"
# Load Library
library(devtools)
#~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
# Create Package
# create(myLibrary)
#~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
#
#~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
# Document, Install, and Reload Library
## Generate Documentation
setwd(paste0("./",myLibrary))
devtools::document()
## Install New Package (locally)
setwd("..") # return to root directory first
devtools::install(myLibrary)
## Reload library
library(myLibrary,character.only = TRUE)
# change wd back to package
setwd(paste0("./",myLibrary))
library(ContDataQC)
help(package="ContDataQC")
# Library Name
myLibrary <- "ContDataQC"
# Load Library
library(devtools)
#~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
# Create Package
# create(myLibrary)
#~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
#
#~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
# Document, Install, and Reload Library
## Generate Documentation
setwd(paste0("./",myLibrary))
devtools::document()
## Install New Package (locally)
setwd("..") # return to root directory first
devtools::install(myLibrary)
## Reload library
library(myLibrary,character.only = TRUE)
# change wd back to package
setwd(paste0("./",myLibrary))
# Library Name
myLibrary <- "ContDataQC"
# Load Library
library(devtools)
#~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
# Create Package
# create(myLibrary)
#~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
#
#~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
# Document, Install, and Reload Library
## Generate Documentation
setwd(paste0("./",myLibrary))
devtools::document()
## Install New Package (locally)
setwd("..") # return to root directory first
devtools::install(myLibrary)
## Reload library
library(myLibrary,character.only = TRUE)
# change wd back to package
setwd(paste0("./",myLibrary))
library(ContDataQC)
help(package="ContDataQC")
library(ContDataQC)
?rarify
# load bio data
DF.biodata <- data_bio2rarify
dim(DF.biodata)
View(DF.biodata)
# subsample
mySize <- 200
Seed.MS <- 18171210
bugs.mysize <- rarify(inbug=DF.biodata, sample.ID="SampRep"
,abund="Count",subsiz=mySize, mySeed=Seed.MS)
# view results
dim(bugs.mysize)
View(bugs.mysize)
# Compare pre- and post- subsample counts
df.compare <- merge(DF.biodata, bugs.mysize, by=c("SampRep", "tax"))
View(df.compare)
# save the data
#write.table(bugs.mysize,paste("bugs",mySize,"txt",sep="."),sep="\t")
# Library Name
myLibrary <- "ContDataQC"
# Load Library
library(devtools)
#~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
# Create Package
# create(myLibrary)
#~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
#
#~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
# Document, Install, and Reload Library
## Generate Documentation
setwd(paste0("./",myLibrary))
devtools::document()
## Install New Package (locally)
setwd("..") # return to root directory first
devtools::install(myLibrary)
## Reload library
library(myLibrary,character.only = TRUE)
# change wd back to package
setwd(paste0("./",myLibrary))
# Library Name
myLibrary <- "ContDataQC"
# Load Library
library(devtools)
#~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
# Create Package
# create(myLibrary)
#~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
#
#~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
# Document, Install, and Reload Library
## Generate Documentation
setwd(paste0("./",myLibrary))
devtools::document()
## Install New Package (locally)
setwd("..") # return to root directory first
devtools::install(myLibrary)
## Reload library
library(myLibrary,character.only = TRUE)
# change wd back to package
setwd(paste0("./",myLibrary))
?library(BioMonTools)
?rarify
??rarify
library(ContDataQC)
library(devtools)
devtools::build_vignettes()
# Library Name
myLibrary <- "ContDataQC"
# Load Library
library(devtools)
#~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
# Create Package
# create(myLibrary)
#~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
#
#~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
# Document, Install, and Reload Library
## Generate Documentation
setwd(paste0("./",myLibrary))
devtools::document()
## Install New Package (locally)
setwd("..") # return to root directory first
devtools::install(myLibrary)
## Reload library
library(myLibrary,character.only = TRUE)
# change wd back to package
setwd(paste0("./",myLibrary))
library(ContDataQC)
help(package="ContDataQC")
# Library Name
myLibrary <- "ContDataQC"
# Load Library
library(devtools)
#~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
# Create Package
# create(myLibrary)
#~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
#
#~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
# Document, Install, and Reload Library
## Generate Documentation
setwd(paste0("./",myLibrary))
devtools::document()
## Install New Package (locally)
setwd("..") # return to root directory first
devtools::install(myLibrary)
## Reload library
library(myLibrary,character.only = TRUE)
# change wd back to package
setwd(paste0("./",myLibrary))
library(ContDataQC)
help(package="ContDataQC")
