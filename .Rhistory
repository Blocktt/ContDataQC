# ContData.env$myFlagVal.Fail    <- "F"
# ContData.env$myName.Flag        <- "Flag" # flag prefix
# ContData.env$myName.Flag.WaterTemp  <- paste(ContData.env$myName.Flag,ContData.env$myName.WaterTemp,sep=".")
# #Trigger for Stats to exclude (TRUE) or include (FALSE) where flag = "fail"
# ContData.env$myStats.Fails.Exclude <- TRUE
#
# QC.1. Define parameter flag field
## If flag parameter names is different from config then it won't be found
myParam.Name.Flag <- paste(ContData.env$myName.Flag, i, sep=".")
# QC.2. Modify columns to keep (see 3.2.) based on presence of "flag" field
## give user feedback
if (myParam.Name.Flag %in% names(df.load)) {##IF.flagINnames.START
# QC.2.1. Flag field present in data
myCol <- c(fun.myDateTime.Name, i, myParam.Name.Flag)
# QC.2.1.1. Convert "Fails" to NA where appropriate
if (ContData.env$myStats.Fails.Exclude == TRUE) {##IF.Fails.START
# find Fails
myFails <- df.load[,myParam.Name.Flag]==ContData.env$myFlagVal.Fail
myFails.Num <- sum(myFails)
# convert to NA
df.load[myFails, i] <- NA
# Message to User
myMsg <- paste0("QC Flag field was found and ", myFails.Num, " fails were excluded based on user's config file.")
} else {
# Message to User
myMsg <- "QC Flag field was found and fails were all included based on user's config file."
}##IF.Fails.END
#
} else {
# QC.2.2. No Flag column
myCol <- c(fun.myDateTime.Name, i)
myMsg <- "No QC Flag field was found so all data points were used in calculations."
}##IF.flagINnames.END
cat(paste0(myMsg, "\n"))
# 3. Munge Data####
# 3.1. Subset Fields
df.param <- df.load[,myCol]
# 3.2. Add "Date" field
myDate.Name <- "Date"
df.param[,myDate.Name] <- as.Date(df.param[,fun.myDateTime.Name], fd01)
# 3.3. Data column to numeric
# may get "NAs introduced by coercion" so suppress
df.param[,i] <- suppressWarnings(as.numeric(df.param[,i]))
#~~~~~~~~~~~~~~~~~~~~~~~~~
# OLD method using doBy
# 4. Daily Stats for data####
# Calculate daily mean, max, min, range, sd, n
# 4.1. Define FUNCTION for use with summaryBy
myQ <- c(0.01,0.05,0.10,0.25,0.50,0.75,0.90,0.95,0.99)
myFUN.Names <- c("mean","median","min","max","range","sd","var","cv","n",paste("q",formatC(100*myQ,width=2,flag="0"),sep=""))
#
myFUN.sumBy <- function(x, ...){##FUN.myFUN.sumBy.START
c(mean=mean(x,na.rm=TRUE)
,median=median(x,na.rm=TRUE)
,min=min(x,na.rm=TRUE)
,max=max(x,na.rm=TRUE)
,range=max(x,na.rm=TRUE)-min(x,na.rm=TRUE)
,sd=sd(x,na.rm=TRUE)
,var=var(x,na.rm=TRUE)
,cv=sd(x,na.rm=TRUE)/mean(x,na.rm=TRUE)
,n=length(x)
,q=quantile(x,probs=myQ,na.rm=TRUE)
)
}##FUN.myFUN.sumBy.END
# 4.2.  Rename data column (summaryBy doesn't like variables)
names(df.param)[match(i,names(df.param))] <- "x"
# 4.2. Summary
df.summary <- doBy::summaryBy(x ~ Date, data=df.param, FUN=myFUN.sumBy, na.rm=TRUE
, var.names=i)
# 20181115, Save df.summary for report
if(i.num==1){##FOR.i.num.START
df.summary.plot.1 <- df.summary
} else if (i.num==2){
df.summary.plot.2 <- df.summary
}
#~~~~~~~~~~~~~~~~~~~~~~~~~
# # 4. Daily stats
# # dplyr summary (not working with variable name)
# x <- quo(fun.myParam.Name)
# df.summary <- df.param %>%
#                 dplyr::group_by(Date) %>%
#                   dplyr::summarise(n=n()
#                                    #,min=min(fun.myParam.Name,na.rm=TRUE)
#                                     ,mean=mean(!!x,na.rm=TRUE)
#                                    # ,max=mean(fun.myParam.Name,na.rm=TRUE)
#                                    # ,sd=sd(fun.myParam.Name,na.rm=TRUE)
#                                    )
# 5. Determine period start date####
# Loop through each Period (N and Units)
numPeriods <- length(fun.myPeriod.N)
myDate.Start <- rep(myDate.End, numPeriods)
for (k in 1:numPeriods) {##FOR.k.START
if(tolower(fun.myPeriod.Units[k])=="d" ) {##IF.format.START
# day, $mday
myDate.Start[k]$mday <- myDate.End$mday - (fun.myPeriod.N[k] - 1)
} else if(tolower(fun.myPeriod.Units[k])=="y") {
# year, $year
myDate.Start[k]$year <- myDate.End$year - fun.myPeriod.N[k]
myDate.Start[k]$mday <- myDate.End$mday + 1
} else {
myMsg <- paste0("Provided period units (",fun.myPeriod.Units
,") unrecognized.  Accepted values are 'd', 'm', or 'y').")
stop(myMsg)
}##IF.format.END
}##FOR.k.END
# 20181114, change from i to k
#~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
# # single period
# myDate.Start <- myDate.End
# if(tolower(fun.myPeriod.Units)=="d" ) {##IF.format.START
#   # day, $mday
#   myDate.Start$mday <- myDate.End$mday - (fun.myPeriod.N - 1)
# } else if(tolower(fun.myPeriod.Units)=="y") {
#   # year, $year
#   myDate.Start$year <- myDate.End$year - fun.myPeriod.N
#   myDate.Start$mday <- myDate.End$mday + 1
# } else {
#   myMsg <- paste0("Provided period units (",fun.myPeriod.Units
#                   ,") unrecognized.  Accepted values are 'd', 'm', or 'y').")
#   stop(myMsg)
# }##IF.format.END
#~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
# # 6.0. Subset Date Range
# df.subset <- df.subset[df.subset[,myDate.Name]>=myDate.Start & df.subset[,myDate.Name]<=myDate.End,]
# # df.period <- df.summary %>%
# #               dplyr::filter(myDate.Name>=myDate.Start, myDate.Name<=myDate.End)
#~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
# 6. Subset and Save summary file ####
myDate <- format(Sys.Date(),"%Y%m%d")
myTime <- format(Sys.time(),"%H%M%S")
myFile.Export.ext <- ".csv"
myFile.Export.base <- substr(fun.myFile,1,nchar(fun.myFile)-4)
# Loop through sets
# numPeriods defined above
for (j in 1:numPeriods){##FOR.j.START
# subset
df.summary.subset <- df.summary[df.summary[,myDate.Name]>=as.Date(myDate.Start[j]) & df.summary[,myDate.Name]<=as.Date(myDate.End),]
# create file name
myFile.Export.full <- paste0(paste(myFile.Export.base
,"PeriodStats"
,fun.myDate
,i
,paste0(fun.myPeriod.N[j],fun.myPeriod.Units[j])
,myDate
,myTime
,sep="_")
,myFile.Export.ext)
# save
write.csv(df.summary.subset, file.path(fun.myDir.export, myFile.Export.full),quote=FALSE,row.names=FALSE)
}##FOR.j.END
#
}##FOR.i.END
# 7. Generate markdown summary file with plots ####
# extra info for report (20180118)
myDate.File.Min <- min(df.load$Date)
myDate.Diff.FileMin.Benchmark <- as.Date(fun.myDate) - as.Date(myDate.File.Min)
# Error Check, Report Format
if(fun.myReport.format==""){
fun.myReport.format <- ContData.env$myReport.Format
}
fun.myReport.format <- tolower(fun.myReport.format)
# 20180212
# Error Check, Report Directory
if(fun.myReport.Dir==""){
fun.myReport.Dir <- ContData.env$myReport.Dir
}
#myReport.Name <- paste0("Report_PeriodStats","_",fun.myReport.format)
myReport.Name <- "Report_PeriodStats"
myPkg <- "ContDataQC"
if(boo_DEBUG==TRUE){
strFile.RMD <- file.path(getwd(),"inst","rmd",paste0(myReport.Name,".rmd")) # for testing
} else {
#strFile.RMD <- system.file(paste0("rmd/",myReport.Name,".rmd"),package=myPkg)
# use provided dir for template
strFile.RMD <- file.path(fun.myReport.Dir, paste0(myReport.Name, ".rmd"))
}
#
#
strFile.out.ext <- paste0(".",fun.myReport.format) #".docx" # ".html"
strFile.out <- paste0(paste(myFile.Export.base,"PeriodStats",fun.myDate,paste(fun.myParam.Name,collapse="_"),myDate,myTime,sep="_"), strFile.out.ext)
strFile.RMD.format <- paste0(ifelse(fun.myReport.format=="docx","word",fun.myReport.format),"_document")
#
knitr::opts_chunk$set(results='asis', echo=FALSE, warning=FALSE)
# needed for trouble shooting
#myConfig <- file.path(system.file(package="ContDataQC"), "extdata", "config.ORIG.R")
#source(myConfig)
# Report Info
myReportDate <- format(Sys.Date(),fun.myDate.Format)
# myReportDate <- format(Sys.Date(),fd01)
cat(paste("**Report Date:** ",myReportDate,"\n\n",sep=""))
myUser <- Sys.getenv("USERNAME")
cat(paste("**Generated By:** ",myUser,"\n\n",sep=""))
cat("**Benchmark Date:** ",fun.myDate,collapse="\n\n",sep="")
cat("**Period (N, Units):** ",paste(fun.myPeriod.N[1:numPeriods]
,fun.myPeriod.Units[1:numPeriods], collapse=", ", sep="")
, collapse="\n\n", sep="")
cat(paste("**Period Start Date:** ",paste(as.Date(myDate.Start[1:numPeriods]),collapse=", "),sep=""),collapse="\n\n")
cat("**Minimum Date in File:** ", myDate.File.Min, collapse="\n\n", sep="")
cat("**Difference (Benchmark-Minimum Date):** ", myDate.Diff.FileMin.Benchmark, collapse="\n\n", sep="")
cat("**Parameter(s):** ",paste(fun.myParam.Name,collapse=", ",sep=""),collapse="\n\n",sep="")
cat("**Threshold:** ",fun.myThreshold,collapse="\n\n",sep="")
cat("**QC Flag Failures Exclude:** ",ContData.env$myStats.Fails.Exclude,collapse="\n\n",sep="")
cat("**Filename, Input:** ",fun.myFile,"\n\n",sep="")
#cat("**Filename, Output:** ",paste0(myFile.Export.part,myFile.Export.ext),sep="")
fun.myParam.Name
m <- fun.myParam.Name[1]
m.num <- match(m, fun.myParam.Name)
# print header 2
cat("\n\n")
cat("## ",fun.myParam.Name[m.num],sep="")
cat("\n\n")
flush.console()
#
# select df based on iteration
if(m.num==1){##IF.m.num.START
df.summary.plot <- df.summary.plot.1
} else if (m.num==2){
df.summary.plot <- df.summary.plot.2
}##IF.m.num.END
m
for (n in 1:numPeriods){##FOR.n.START
# subset
df.plot <- df.summary.plot[df.summary.plot[,myDate.Name]>=as.Date(myDate.Start[n]) & df.summary.plot[,myDate.Name]<=as.Date(myDate.End), ]
# create file name
plot(df.plot[,1:2]
, main=paste0(fun.myDate," \n(",fun.myPeriod.N[n],fun.myPeriod.Units[n],")")
)
# Add line
if(!is.na(fun.myThreshold)){
abline(h=fun.myThreshold)
}
}
str(df.summary.plot)
x_name <- names(df.summary)[1]
y_name <- names(df.summary)[2]
ggplot(df.summary.plot) +
ggplot2::geom_point(aes_q(x=as.name(x_name), y=as.name(y_name)))
ggplot2::ggplot(df.summary.plot) +
ggplot2::geom_point(ggplot2::aes_q(x=as.name(x_name), y=as.name(y_name)))
names(df.summary)[1]
names(df.summary)[2]
m.num
# select df based on iteration
if(m.num==1){##IF.m.num.START
df.summary.plot <- df.summary.plot.1
} else if (m.num==2){
df.summary.plot <- df.summary.plot.2
}##IF.m.num.END
#~~~~~~~~~~~~~~~~~~
# ggplot alternative
#~~~~~~~~~~~~~~~~~~
x_name <- names(df.summary)[1]
y_name <- names(df.summary)[2]
ggplot2::ggplot(df.summary.plot) +
ggplot2::geom_point(ggplot2::aes_q(x=as.name(x_name), y=as.name(y_name)))
str(df.summary.plot)
p_ps <- ggplot2::ggplot(df.summary.plot) +
ggplot2::geom_point(ggplot2::aes_q(x=as.name(x_name), y=as.name(y_name)))
print(p_ps)
x_name <- names(df.summary.plot)[1]
y_name <- names(df.summary.plot)[2]
p_ps <- ggplot2::ggplot(df.summary.plot) +
ggplot2::geom_point(ggplot2::aes_q(x=as.name(x_name), y=as.name(y_name)))
print(p_ps)
p_ps
p_ps <- ggplot2::ggplot(df.summary.plot) +
ggplot2::geom_point(ggplot2::aes_q(x=as.name(x_name), y=as.name(y_name))) +
ggplot2::labs(title=mySiteID) +
ggplot2::theme(plot.title=ggplot2::element_text(hjust=0.5)
, plot.subtitle=ggplot2::element_text(hjust=0.5))
print(p_ps)
str_title    <- fun.myDate
str_subtitle <- paste0(fun.myPeriod.N[n], fun.myPeriod.Units[n])
p_ps <- ggplot2::ggplot(df.summary.plot) +
ggplot2::geom_point(ggplot2::aes_q(x=as.name(x_name), y=as.name(y_name))) +
ggplot2::labs(title=str_title, subtitle=str_subtitle) +
ggplot2::theme(plot.title=ggplot2::element_text(hjust=0.5)
, plot.subtitle=ggplot2::element_text(hjust=0.5))
print(p_ps)
str_title    <- fun.myDate
str_subtitle <- paste0("(", fun.myPeriod.N[n], fun.myPeriod.Units[n], ")")
p_ps <- ggplot2::ggplot(df.summary.plot) +
ggplot2::geom_point(ggplot2::aes_q(x=as.name(x_name), y=as.name(y_name))) +
ggplot2::labs(title=str_title, subtitle=str_subtitle) +
ggplot2::theme(plot.title=ggplot2::element_text(hjust=0.5)
, plot.subtitle=ggplot2::element_text(hjust=0.5))
print(p_ps)
p_ps + geom_hline(ggplot2::aes_string(yintercept=fun.myThreshold))
p_ps + ggplot2::geom_hline(ggplot2::aes_string(yintercept=fun.myThreshold))
param.len
p <- 1
myParam.Name <- c("Water.Temp.C", "Sensor.Depth.ft")
PeriodStats(myDate
, myDate.Format
, myPeriod.N
, myPeriod.Units
, myFile
, myDir.import
, myDir.export
, myParam.Name
, myDateTime.Name
, myDateTime.Format
, myThreshold
, myConfig.Fail.Include
, myReport.format)
?PeriodStats
PeriodStats(myDate
, myDate.Format
, myPeriod.N
, myPeriod.Units
, myFile
, myDir.import
, myDir.export
, myParam.Name
, myDateTime.Name
, myDateTime.Format
, myThreshold
, myConfig)
# function inputs
myDate <- "2013-09-30"
myDate.Format <- "%Y-%m-%d"
myPeriod.N <- c(30, 60, 90, 120, 1)
myPeriod.Units <- c("d", "d", "d", "d", "y")
myFile <- "DATA_period_test2_Aw_20130101_20141231.csv"
myDir.import <- getwd()
myDir.export <- getwd()
myParam.Name <-  c("Water.Temp.C", "Sensor.Depth.ft")
myDateTime.Name <- "Date.Time"
myDateTime.Format <- "%Y-%m-%d %H:%M:%S"
myThreshold <- 20
myConfig <- ""
myReport.format <- "html"
# Custom Config
myConfig.Fail.Include  <- "config.ExcludeFailsFalse.R"
myParam.Name <- c("Water.Temp.C", "Sensor.Depth.ft")
PeriodStats(myDate
, myDate.Format
, myPeriod.N
, myPeriod.Units
, myFile
, myDir.import
, myDir.export
, myParam.Name
, myDateTime.Name
, myDateTime.Format
, myThreshold
, myConfig.Fail.Include
, myReport.format)
# NEWS
# Render then Copy NEWS so picked up in help
rmarkdown::render("NEWS.rmd", "all")
file.copy("NEWS.md", "NEWS", overwrite = TRUE)
file.remove("NEWS.html")
file.remove("NEWS.md")
#
# Library Name
myLibrary <- "ContDataQC"
# Load Library
library(devtools)
#~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
# Create Package
# create(myLibrary)
#~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
#
#~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
# Document, Install, and Reload Library
## Generate Documentation
setwd(paste0("./",myLibrary))
devtools::document()
## Install New Package (locally)
setwd("..") # return to root directory first
devtools::install(myLibrary)
## Reload library
library(myLibrary,character.only = TRUE)
# change wd back to package
setwd(paste0("./",myLibrary))
pkg <- "ContDataQC"
library(pkg, character.only = TRUE)
help(package=(pkg))
#
?PeriodStats
# Load File to use for PeriodStats
myDir <- getwd()
myFile <- "DATA_period_test2_Aw_20130101_20141231.csv"
df.x <- read.csv(file.path(myDir, myFile))
# function inputs
myDate <- "2013-09-30"
myDate.Format <- "%Y-%m-%d"
myPeriod.N <- c(30, 60, 90, 120, 1)
myPeriod.Units <- c("d", "d", "d", "d", "y")
myFile <- "DATA_period_test2_Aw_20130101_20141231.csv"
myDir.import <- getwd()
myDir.export <- getwd()
myParam.Name <- "Water.Temp.C"
myDateTime.Name <- "Date.Time"
myDateTime.Format <- "%Y-%m-%d %H:%M:%S"
myThreshold <- 20
myConfig <- ""
myReport.format <- "docx"
# Custom Config
myConfig.Fail.Include  <- "config.ExcludeFailsFalse.R"
# Run Function
## Example 1. default report format (html)
PeriodStats(myDate
, myDate.Format
, myPeriod.N
, myPeriod.Units
, myFile
, myDir.import
, myDir.export
, myParam.Name
, myDateTime.Name
, myDateTime.Format
, myThreshold
, myConfig)
# NEWS
# Render then Copy NEWS so picked up in help
rmarkdown::render("NEWS.rmd", "all")
file.copy("NEWS.md", "NEWS", overwrite = TRUE)
file.remove("NEWS.html")
file.remove("NEWS.md")
#
# Library Name
myLibrary <- "ContDataQC"
# Load Library
library(devtools)
#~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
# Create Package
# create(myLibrary)
#~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
#
#~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
# Document, Install, and Reload Library
## Generate Documentation
setwd(paste0("./",myLibrary))
devtools::document()
## Install New Package (locally)
setwd("..") # return to root directory first
devtools::install(myLibrary)
## Reload library
library(myLibrary,character.only = TRUE)
# change wd back to package
setwd(paste0("./",myLibrary))
pkg <- "ContDataQC"
library(pkg, character.only = TRUE)
help(package=(pkg))
# Load File to use for PeriodStats
myDir <- getwd()
myFile <- "DATA_period_test2_Aw_20130101_20141231.csv"
df.x <- read.csv(file.path(myDir, myFile))
# function inputs
myDate <- "2013-09-30"
myDate.Format <- "%Y-%m-%d"
myPeriod.N <- c(30, 60, 90, 120, 1)
myPeriod.Units <- c("d", "d", "d", "d", "y")
myFile <- "DATA_period_test2_Aw_20130101_20141231.csv"
myDir.import <- getwd()
myDir.export <- getwd()
myParam.Name <- "Water.Temp.C"
myDateTime.Name <- "Date.Time"
myDateTime.Format <- "%Y-%m-%d %H:%M:%S"
myThreshold <- 20
myConfig <- ""
myReport.format <- "docx"
# Custom Config
myConfig.Fail.Include  <- "config.ExcludeFailsFalse.R"
# Run Function
## Example 1. default report format (html)
PeriodStats(myDate
, myDate.Format
, myPeriod.N
, myPeriod.Units
, myFile
, myDir.import
, myDir.export
, myParam.Name
, myDateTime.Name
, myDateTime.Format
, myThreshold
, myConfig)
# NEWS
# Render then Copy NEWS so picked up in help
rmarkdown::render("NEWS.rmd", "all")
file.copy("NEWS.md", "NEWS", overwrite = TRUE)
file.remove("NEWS.html")
file.remove("NEWS.md")
#
# Library Name
myLibrary <- "ContDataQC"
# Load Library
library(devtools)
#~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
# Create Package
# create(myLibrary)
#~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
#
#~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
# Document, Install, and Reload Library
## Generate Documentation
setwd(paste0("./",myLibrary))
devtools::document()
## Install New Package (locally)
setwd("..") # return to root directory first
devtools::install(myLibrary)
## Reload library
library(myLibrary,character.only = TRUE)
# change wd back to package
setwd(paste0("./",myLibrary))
# Restart R within RStudio:  Ctrl + Shift + F10
pkg <- "ContDataQC"
library(pkg, character.only = TRUE)
help(package=(pkg))
